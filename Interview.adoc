= Interview
:source-language: java
:source-highlighter: pygments

== Java

=== 기본형
    * 논리형 : true, false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용
        ** boolean : 1byte (false, true)
    * 문자형 : 문자를 저장하는데 사용되며, 변수 당 하나의 문자만을 저장할 수 있음
        ** char : 2byte (u0000~uffff, 0~2^16)
    * 정수형 : 정수 값을 저장하는 데 사용된다 주로 사용되는 것은 int, long
        ** byte : 1byte (-128 ~ 127, -2^7~2^7)
        ** short : 2byte (-32768 ~ 32767, -2^15~2^15-1)
        ** int : 4byte (-2147483648 ~ 2147483647, -2^31~2^31-1)
        ** long : 8byte (-9223372036854775808 ~ 9223372036854775807, -2^63~2^63-1)
    * 실수형 : 실수 값을 저장하는데 사용됨 float, double
        ** float : 4byte
        ** double : 8byte

=== String, StringBuffer, StringBuilder 차이
 * String : Immutable(불변) String 클래스의 객체는 Heap 상에 생성될 경우 한번 생성된 객체는 내부 내용을 변경 할 수 없음
 * StringBuffer : Thread Safe
 * StringBuilder : Thread Safe X

=== 용어

* Thread Safe : 여러 쓰레드에 의해 코드가 실행되더라도 실행 결과의 보장

* Hiding
** 부모 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스와 동일한 이름으로 자식 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스의 이름을 만들면, 자식에서 만든 요소가 부모에 있는 요소를 하이딩함

* Shadowing
** 변수, 메서드, 클래스, 인터페이스의 이름을 같은 영역에서 동일하게 사용하면 이름이 겹쳐 새도윙이 발생
** 어떤 대상이 섀도윙되면, 해당 대상을 이름으로 접근할 수 없음

* Deep copy, Shallow Copy
** 배열이나 객체를 복사할 때 단순히 참조만 복사하는 것을 shallow copy, 원본과 같은 데이터를 저장하고 있는 새로운 객체나 배열을 생성하는 것은 deep copy

* 접근제한자

** 종류
*** default : 같은 패키지(폴더)에 있는 객체들만 허용
*** public : 모든 접근을 허용
*** private : 현재 객체 내에서만 허용
*** protected : 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용

** 사용
*** 클래스 : public, default
*** 생성자 : public, protected, default, private
*** 멤버변수 : public, protected, default, private
*** 멤버메소드 : public, protected, default, private
*** 지역변수 : 접근제한자 사용 불허

* final
** 변수에 적용하면 : 해당 변수의 값은 변경이 불가능
** 변수의 참조에 적용하면 : 참조 변수가 힙 내의 대란 객체를 가리키도록 변경 할 수 없음
** 메서드에 적용하면 : 해당 메서드를 오버라이드 할 수 없음
** 클래스에 적용하면 : 해당 클래스의 하위 클래스를 정의 할 수 없음

* finally
** try 블록 또는 catch 블록 뒤에 둘 수 있는 선택적인 블록을 정의할 때 사용
** finally 블록 내에 둔 코드는 항상 실행
** finally 블록은 뒷마무리 코드를 작성하는데 사용

* finalize()
** finalize() 메서드는 GC가 더 이상의 참조가 존재하지 않는 객체를 발견한 순간 호출하는 메서드
** 파일을 닫는 등, 자원 반환 작업을 하는데 보통 사용

=== Generic
* 제네릭을 사용하면 컬렉션에 넣는 객체의 자료형이 무엇인지 컴파일러에게 알림
* 안전하고 명료해지지만, 프로그램이 복잡해짐
* 공변성(Covariance)과 반공변성(Contravariance)은 원래 지정된 것보다 더 적게 파생되거나(덜 구체적인) 더 많이 파생된 형식(더 구체적인)을 사용할 수 있는 능력을 지칭하는 용어
* 공변성 (Covariant) : 원래 지정된 것보다 더 많이 파생된 형식을 사용할 수 있습니다.
* 반공변성 (Contravariance) : 원래 지정된 것보다 더 제네릭한(덜 파생적인) 형식을 사용할 수 있습니다.
* 불변량 : Invariance : 원래 지정된 형식만 사용할 수 있다는 의미이므로, 불변하는 제네릭 형식 매개 변수는 공변성도, 반공변성도 아닙니다.
* PECS : Produce - Extends, Consumer - Super

[source,java, indent=0]
----
// E 객체 생산자 역할을 하는 인자에 대한 와일드 카드 자료형
public void putAll(Iterable<? extends E> src) {
    for (E e : src)
        push(e);
}
----

[source,java, indent=0]
----
// E의 소비자 구실을 하는 인자에 대한 와일드카드 자료형
public void popAll(Collection<? super E> dst) {
    while(!isEmpty())
        dst.add(pop());
}
----

=== Java Virtual Machine
* 가상 머신(virtual machine)이란 여러 가지로 정의할 수 있지만, 프로그램을 실행하기 위해 물리적 머신(즉, 컴퓨터)과 유사한 머신을 소프트웨어로 구현한 것을 말한다고 할 수 있다.
지금은 비록 빛이 바랜 목표이긴 하나 자바는 원래 WORA(Write Once Run Anywhere)를 구현하기 위해 물리적인 머신과 별개의 가상 머신을 기반으로 동작하도록 설계되었다.
그래서 자바 바이트코드를 실행하고자 하는 모든 하드웨어에 JVM을 동작시킴으로써 자바 실행 코드를 변경하지 않고도 모든 종류의 하드웨어에서 동작되게 한 것

==== 자바 바이트코드
* WORA를 구현하기 위해 JVM은 사용자 언어인 자바와 기계어 사이의 중간 언어인 자바 바이트코드를 사용한다. 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 단위

==== JVM 특징 [http://d2.naver.com/helloworld/1230]
* 스택 기반의 가상 머신: 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작
* 심볼릭 레퍼런스: 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조
* 가비지 컬렉션(garbage collection): 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴
* 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장: C/C++ 등의 전통적인 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장
* 네트워크 바이트 오더(network byte order): 자바 클래스 파일은 네트워크 바이트 오더를 사용한다.
인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크
바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.
 * 오라클 핫스팟 JVM 외에도 IBM JVM을 비롯한 다양한 JVM이 존재

[.center.text-center]
.JVM 구조
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-1.png[align="center", title-align="center"]

** 자바로 작성한 코드는 클래스 로더(Class Loader)가 컴파일된 자바 바이트코드를 런타임 데이터 영역(Runtime Data Areas)에 로드하고, 실행 엔진(Execution Engine)이 자바 바이트코드를 실행
** 클래스 로더
*** 자바는 동적 로드, 즉 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더
*** 각 클래스 로더는 로드된 클래스들을 보관하는 네임스페이스(namespace)를 갖는다.
클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해서 네임스페이스에 보관된 FQCN(Fully Qualified Class Name)을 기준으로 클래스를 찾는다.
비록 FQCN이 같더라도 네임스페이스가 다르면, 즉 다른 클래스 로더가 로드한 클래스이면 다른 클래스로 간주
*** 클래스 로더가 클래스 로드를 요청받으면, 클래스 로더 캐시, 상위 클래스 로더, 자기 자신의 순서로 해당 클래스가 있는지 확인 (즉, 이전에 로드된 클래스인지 클래스 로더 캐시를 확인하고, 없으면 상위 클래스 로더를 거슬러 올라가며 확인)
*** 부트스트랩 클래스 로더까지 확인해도 없으면 요청받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾음

*** 클래스 로더 특징
**** 계층 구조: 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더(Bootstrap Class Loader)
**** 위임 모델: 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 먼저 상위 클래스 로더를 확인하여 상위 클래스 로더에 있다면 해당 클래스를 사용하고, 없다면 로드를 요청받은 클래스 로더가 클래스를 로드함
**** 가시성(visibility) 제한: 하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없음
**** 언로드 불가: 클래스 로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 언로드 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있음

[.center.text-center]
.클래스 로더 위임 모델
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-2.png[align="center", title-align="center"]

*** 클래스 로더 위임 모델
**** 부트스트랩 클래스 로더: JVM을 기동할 때 생성되며, Object 클래스들을 비롯하여 자바 API들을 로드 다른 클래스 로더와 달리 자바가 아니라 네이티브 코드로 구현
**** 익스텐션 클래스 로더(Extension Class Loader): 기본 자바 API를 제외한 확장 클래스들을 로드 다양한 보안 확장 기능 등을 여기에서 로드
**** 시스템 클래스 로더(System Class Loader): 부트스트랩 클래스 로더와 익스텐션 클래스 로더가 JVM 자체의 구성 요소들을 로드하는 것이라 한다면, 시스템 클래스 로더는 애플리케이션의 클래스들을 로드한다고 할 수 있음
**** 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드
**** 사용자 정의 클래스 로더(User-Defined Class Loader): 애플리케이션 사용자가 직접 코드 상에서 생성해서 사용하는 클래스 로더
*** 웹 애플리케이션 서버(WAS)와 같은 프레임워크는 웹 애플리케이션들, 엔터프라이즈 애플리케이션들이 서로 독립적으로 동작하게 하기 위해 사용자 정의 클래스 로더를 사용 (클래스 로더의 위임 모델을 통해 애플리케이션의 독립성을 보장)
*** WAS의 클래스 로더 구조는 WAS 벤더마다 조금씩 다른 형태의 계층 구조를 사용

[.center.text-center]
.클래스 로드 단계
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-3.png[클래스 로드 단계]

**** 로드: 클래스를 파일에서 가져와서 JVM의 메모리에 로드
**** 검증(Verifying): 읽어 들인 클래스가 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사
클래스 로드의 전 과정 중에서 가장 까다로운 검사를 수행하는 과정으로서 가장 복잡하고 시간이 많이 걸린다.
JVM TCK의 테스트 케이스 중에서 가장 많은 부분이 잘못된 클래스를 로드하여 정상적으로 검증 오류를 발생시키는지 테스트하는 부분
**** 준비(Preparing): 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비
**** 분석(Resolving): 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
**** 초기화: 클래스 변수들을 적절한 값으로 초기화한다. 즉, static initializer들을 수행하고, static 필드들을 설정된 값으로 초기화

* 런타임 데이터 영역
** 런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 6개의 영역으로 나눌 수 있다.
이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area), 런타임 상수 풀(Runtime Constant Pool)은 모든 스레드가 공유해서 사용 +

[.center.text-center]
.런타임 데이터 영역
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-4.png[align="center", title-align="center"]

*** PC 레지스터: PC(Program Counter) 레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC 레지스터는 현재 수행 중인 JVM 명령의 주소를 가짐
*** JVM 스택: JVM 스택은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.
스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택으로, JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다.
예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현

[.center.text-center]
.JVM 스택 구성
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-5.png[align="center", title-align="center"]

*** 스택 프레임: JVM 내에서 메서드가 수행될 때마다 하나의 스택 프레임이 생성되어 해당 스레드의 JVM 스택에 추가되고 메서드가 종료되면 스택 프레임이 제거된다.
각 스택 프레임은 지역 변수 배열(Local Variable Array), 피연산자 스택(Operand Stack), 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다.
지역 변수 배열, 피연산자 스택의 크기는 컴파일 시에 결정되기 때문에 스택 프레임의 크기도 메서드에 따라 크기가 고정
*** 지역 변수 배열: 0부터 시작하는 인덱스를 가진 배열이다. 0은 메서드가 속한 클래스 인스턴스의 this 레퍼런스이고, 1부터는 메서드에 전달된 파라미터들이 저장되며, 메서드 파라미터 이후에는 메서드의 지역 변수들이 저장된다.
*** 피연산자 스택: 메서드의 실제 작업 공간이다. 각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 추가하거나(push) 꺼낸다(pop).
피연산자 스택 공간이 얼마나 필요한지는 컴파일할 때 결정할 수 있으므로, 피연산자 스택의 크기도 컴파일 시에 결정
*** 네이티브 메서드 스택: 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다.
즉, JNI(Java Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 C 스택이나 C++ 스택이 생성
*** 메서드 영역: 메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, Static 변수, 메서드의 바이트코드 등을 보관한다.
메서드 영역은 JVM 벤더마다 다양한 형태로 구현할 수 있으며, 오라클 핫스팟 JVM(HotSpot JVM)에서는 흔히 Permanent Area, 혹은 Permanent Generation(PermGen)이라고 불린다.
**** 1.8 Permanent Generation(PermGen) 에서 MetaSpace 변경
메서드 영역에 대한 가비지 컬렉션은 JVM 벤더의 선택 사항이다.
*** 런타임 상수 풀: 클래스 파일 포맷에서 constant_pool 테이블에 해당하는 영역이다. 메서드 영역에 포함되는 영역이긴 하지만, JVM 동작에서 가장 핵심적인 역할을 수행하는 곳이기 때문에 JVM 명세에서도 따로 중요하게 기술한다.
각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다.
즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.
*** 힙: 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다. 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더의 재량이다.
** 실행 엔진
*** 클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행
*** 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. CPU가 기계 명령어을 하나씩 실행하는 것과 비슷
*** 바이트코드의 각 명령어는 1바이트짜리 OpCode와 추가 피연산자로 이루어져 있으며, 실행 엔진은 하나의 OpCode를 가져와서 피연산자와 함께 작업을 수행한 다음, 다음 OpCode를 수행하는 식으로 동작
*** 자바 바이트코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술
*** 실행 엔진은 이와 같은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경
**** 인터프리터: 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나씩 해석하고 실행하기 때문에 바이트코드 하나하나의 해석은 빠른 대신 인터프리팅 결과의 실행은 느리다는 단점을 가지고 있음
흔히 얘기하는 인터프리터 언어의 단점을 그대로 가지는 것이다. 즉, 바이트코드라는 '언어'는 기본적으로 인터프리터 방식으로 동작
**** JIT(Just-In-Time) 컴파일러: 인터프리터의 단점을 보완하기 위해 도입된 것이 JIT 컴파일러이다.
인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식
네이티브 코드를 실행하는 것이 하나씩 인터프리팅하는 것보다 빠르고, 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 계속 빠르게 수행
*** JIT 컴파일러가 컴파일하는 과정은 바이트코드를 하나씩 인터프리팅하는 것보다 훨씬 오래 걸리므로, 만약 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 훨씬 유리
*** JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행

[.center.text-center]
.자바 컴파일러와 JIT  컴파일러
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-7.png[align="center", title-align="center"]

*** 실행 엔진이 어떻게 동작하는지는 JVM 명세에 규정되지 않았다. 따라서 JVM 벤더들은 다양한 기법으로 실행 엔진을 향상시키고 다양한 방식의 JIT 컴파일러를 도입

[.center.text-center]
.JIT 컴파일러
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-8.png[align="center", title-align="center"]

*** JIT 컴파일러는 바이트코드를 일단 중간 단계의 표현인 IR(Intermediate Representation)로 변환하여 최적화를 수행하고 그 다음에 네이티브 코드를 생성
*** 오라클 핫스팟 VM은 핫스팟 컴파일러라고 불리는 JIT 컴파일러를 사용
*** 핫스팟이라 불리는 이유는 내부적으로 프로파일링을 통해 가장 컴파일이 필요한 부분, 즉 '핫스팟'을 찾아낸 다음, 이 핫스팟을 네이티브 코드로 컴파일하기 때문
*** 핫스팟 VM은 한번 컴파일된 바이트코드라도 해당 메서드가 더 이상 자주 불리지 않는다면, 즉 핫스팟이 아니게 된다면 캐시에서 네이티브 코드를 덜어내고 다시 인터프리터 모드로 동작
*** 핫스팟 VM은 서버 VM과 클라이언트 VM으로 나뉘어 있고, 각각 다른 JIT 컴파일러를 사용

[.center.text-center]
.핫스팟 클라이언트 VM과 서버 VM
image::http://d2.naver.com/content/images/2015/06/helloworld-1230-9.png[]

*** 클라이언트 VM과 서버 VM은 각각 오라클 핫스팟 VM을 실행할 때 입력하는 -client, -server 옵션으로 실행
*** 클라이언트 VM과 서버 VM은 동일한 런타임을 사용하지만 다른 JIT 컴파일러(Simple Compiler)를 사용
*** 서버 VM에서 사용하는 Advanced Dynamic Optimizing Compiler가 더 복잡하고 다양한 성능 최적화 기법을 사용
*** IBM JVM은 JIT 컴파일러뿐만 아니라 IBM JDK 6부터 AOT(Ahead-Of-Time) 컴파일러라는 기능을 도입
**** 한번 컴파일된 네이티브 코드를 여러 JVM이 공유 캐시를 통해 공유해서 사용하는 것을 의미
**** AOT 컴파일러를 통해 이미 컴파일된 코드는 다른 JVM에서도 컴파일하지 않고 사용할 수 있게 하는 것
**** 아예 AOT 컴파일러를 이용하여 JXE(Java EXecutable)라는 파일 포맷으로 프리컴파일(pre-compile)된 코드를 작성하여 빠르게 실행하는 방법도 제공
*** 오라클 핫스팟 VM은 1.3부터 핫스팟 컴파일러를 내장하기 시작하였고, 안드로이드 Dalvik VM은 안드로이드 2.2부터 JIT 컴파일러를 도입

==== Tip
* Java 메서드 크기 65535바이트 제한
* Assertion -ea 필요

=== Java Garbage Collection [http://d2.naver.com/helloworld/1329]
* Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 가비지 컬렉터(Garbage Collector)가 더 이상 필요 없는 객체를 찾아 지우는 작업을 함

==== 가비지 컬렉션 과정 - Generational Garbage Collection
* 가비지 컬렉터는 두 가지 가설 하에 만듬
** 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 됨
** 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재
* HotSpot VM에서는 크게 2개로 물리적 공간을 나눔

[.text-center]
.영역 및 데이터 흐름도
image::http://d2.naver.com/content/images/2015/06/helloworld-1329-1.png[align="center"]

** Young 영역(Yong Generation 영역): 새롭게 생성한 객체의 대부분이 여기에 위치, 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말함
** Old 영역(Old Generation 영역): 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말함
** Old 영역에서 살아남은 객체가 영원히 남아 있는 곳은 절대 아님
** Permanent Generation 영역(이하 Perm 영역) 이 영역에서 GC가 발생할 수도 있는데, 여기서 GC가 발생해도 Major GC의 횟수에 포함
** Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우
*** Old 영역에는 512바이트의 덩어리(chunk)로 되어 있는 카드 테이블(card table)이 존재
*** 카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시
*** Young 영역의 GC를 실행할 때에는 Old 영역에 있는 모든 객체의 참조를 확인하지 않고, 이 카드 테이블만 뒤져서 GC 대상인지 식별
*** 카드 테이블은 write barrier를 사용하여 관리
*** write barrier는 Minor GC를 빠르게 할 수 있도록 하는 장치
*** write barrirer때문에 약간의 오버헤드는 발생하지만 전반적인 GC 시간은 줄어들게 됨

[.text-center]
.카드 테이블 구조
image::http://d2.naver.com/content/images/2015/06/helloworld-1329-2.png[align="center", title-align="center"]

===== Young 영역의 구성
* GC를 이해하기 위해서 객체가 제일 먼저 생성되는 Young 영역부터 알아보자. Young 영역은 3개의 영역으로 나뉨
* Eden 영역, Survivor 영역(2개)
* 각 영역의 처리 절차
** 새로 생성한 대부분의 객체는 Eden 영역에 위치
** Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동
** Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓임
** 하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동 그리고 가득 찬 Survivor 영역은 아무 데이터도 없는 상태로 됨
** 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 됨
* Survivor 영역 중 하나는 반드시 비어 있는 상태
* 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 여러분의 시스템은 정상적인 상황이 아님

[.text-center]
.GC 전과 후의 비교
image::http://d2.naver.com/content/images/2015/06/helloworld-1329-3.png[align="center", title-align="center"]

===== Old 영역에 대한 GC

* Serial GC (-XX:+UseSerialGC)
** Old 영역의 GC는 mark-sweep-compact이라는 알고리즘을 사용
** 첫 단계는 Old 영역에 살아 있는 객체를 식별(Mark)하는 것
** 다음에는 힙(heap)의 앞 부분부터 확인하여 살아 있는 것만 남김
** 마지막 단계에서는 각 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눔
** Serial GC는 적은 메모리와 CPU 코어 개수가 적을 때 적합한 방식
* Parallel GC (-XX:+UseParallelGC)
** Parallel GC는 Serial GC와 기본적인 알고리즘은 같음
** Serial GC는 GC를 처리하는 스레드가 하나인 것에 비해, Parallel GC는 GC를 처리하는 쓰레드가 여러 개
** Serial GC보다 빠른게 객체를 처리할 수있음
** Parallel GC는 메모리가 충분하고 코어의 개수가 많을 때 유리
** Parallel GC는 Throughput GC라고도 부름

[.text-center]
.Serial GC와 Parallel GC
image::http://d2.naver.com/content/images/2015/06/helloworld-1329-4.png[]

* Parallel Old GC (Parallel Compacting GC)
** Parallel Old GC는 JDK 5 update 6부터 제공한 GC 방식
** Parallel GC와 비교하여 Old 영역의 GC 알고리즘만 다름
** 이 방식은 Mark-Summary-Compaction 단계를 거침
** Summary 단계는 앞서 GC를 수행한 영역에 대해서 별도로 살아 있는 객체를 식별한다는 점에서 Mark-Sweep-Compaction 알고리즘의 Sweep 단계와 다르며, 약간 더 복잡한 단계를 거침
* Concurrent Mark & Sweep GC(이하 CMS) (-XX:+UseConcMarkSweepGC)
** 초기 Initial Mark 단계에서는 클래스 로더에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝냄.
** 멈추는 시간은 매우 짧음
** Concurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인
** 이 단계의 특징은 다른 스레드가 실행 중인 상태에서 동시에 진행됨
** 그 다음 Remark 단계에서는 Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인
** 마지막으로 Concurrent Sweep 단계에서는 쓰레기를 정리하는 작업을 실행 (다른 스레드가 실행되고 있는 상황에서 진행)
** 이러한 단계로 진행되는 GC 방식이기 때문에 stop-the-world 시간이 매우 짧음
** 모든 애플리케이션의 응답 속도가 매우 중요할 때 CMS GC를 사용하며, Low Latency GC라고도 부름
** 다른 GC 방식보다 메모리와 CPU를 더 많이 사용
** Compaction 단계가 기본적으로 제공되지 않음

[.text-center]
.Serial GC와 CMS GC
image::http://d2.naver.com/content/images/2015/06/helloworld-1329-5.png[]

* G1(Garbage First) GC
** G1 GC를 이해하려면 지금까지의 Young 영역과 Old 영역에 대해서는 잊는 것이 좋음
** G1 GC는 바둑판의 각 영역에 객체를 할당하고 GC를 실행
** 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행
** Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식
** G1 GC는 장기적으로 말도 많고 탈도 많은 CMS GC를 대체하기 위해서 만들어짐

[.text-center]
.G1 GC의 레이아웃
image::http://d2.naver.com/content/images/2015/06/helloworld-1329-6.png[]

=== Garbage Collection 튜닝
* -Xms 옵션과 –Xmx 옵션으로메모리크기를지정
* -server 옵션이포함
* 시스템에 Timeout 로그와같은로그가남지않음

==== Old 영역으로 넘어가는 객체의 수 최소화하기
* 간혹 Eden 영역에서 만들어지다가 크기가 커져서 Old 영역으로 바로 넘어가는 객체도 있음
* Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있음

==== Full GC 시간 줄이기
* Full GC의 실행 시간은 상대적으로 Minor GC에 비하여 김
* Full GC 실행에 시간이 오래 소요되면(1초 이상) 연계된 여러 부분에서 타임아웃이 발생할 수 있음
* Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생, Full GC 횟수가 늠
* Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어남
* Old 영역의 크기를 적절하게 '잘' 설정

==== GC의 성능을 결정하는 옵션

. GC 튜닝 시 기본적으로 학인해야 하는 JVM 옵션
|===
|구분 | 옵션 | 설명

|힙(heap) 영역 크기
|-Xms
|JVM 시작 시 힙 영역 크기

|
|-Xmx
|최대 힙 영역 크기

|New 영역의 크기
|-XX:NewRatio
|New 영역과 Old 영역의 비율

|
|-XX:NewSize
|New 영역의 크기

|
|-XX:SurvivorRatio
|Eden 영역과 Survivor 영역의 비율

|===

* GC 튜닝을 할 때 자주 사용하는 옵션은 -Xms 옵션, -Xmx 옵션, -XX:NewRatio 옵션
* -Xms 옵션과 -Xmx 옵션은 필수로 지정해야 하는 옵션
* NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생
* Perm 영역의 크기는 OutOfMemoryError 가 발생하고, 그 문제의 원인이 Perm 영역의 크기 때문일 때에만 -XX:PermSize 옵션과 -XX:MaxPermSize 옵션으로 지정해도 큰 문제없음

.GC 방식에 따라 지정 가능한 옵션
|===
|구분 |옵션 |비고

|Serial GC
|-XX:+UseSerialGC
|

|Parallel GC
|-XX:+UseParallelGC, -XX:ParallelGCThreads=value
|

|Parallel Compacting GC
|-XX:+UseParallelOldGC
|

|CMS GC
|-XX:+UseConcMarkSweepGC, -XX:+UseParNewGC, -XX:+CMSParallelRemarkEnabled, -XX:CMSInitiatingOccupancyFraction=value, -XX:+UseCMSInitiatingOccupancyOnly
|

|G1
|-XX:+UnlockExperimentalVMOptions, -XX:+UseG1GC
|JDK 6에서는 두 옵션을 반드시 같이 사용해야 함
|===

==== GC 튜닝의 절차
1. GC 상황 모니터링
2. 모니터링 결과 분석 후 GC 튜닝 여부 결정
3. GC 방식/메모리 크기 지정
4. 결과 분석
5. 결과가 만족스러울 경우 전체 서버에 반영 및 종료

=== Java Reference와 GC
* Java의 가비지 컬렉터(Garbage Collector)는 그 동작 방식에 따라 매우 다양한 종류가 있음
* 공통적으로 크게 다음 2가지 작업을 수행
** 힙(heap) 내의 객체 중에서 가비지(garbage)를 찾음
** 찾아낸 가비지를 처리해서 힙의 메모리를 회수
* 최초의 Java에서는 이들 가비지 컬렉션(Garbage Collection, 이하 GC) 작업에 애플리케이션의 사용자 코드가 관여하지 않도록 구현됨
* JDK 1.2부터는 java.lang.ref 패키지를 추가해 제한적이나마 사용자 코드와 GC가 상호작용할 수 있음
* java.lang.ref 패키지는 전형적인 객체 참조인 strong reference 외에도 soft, weak, phantom 3가지의 새로운 참조 방식을 각각의 Reference 클래스로 제공

=== 자바 애플리케이션 성능 튜닝의 도(道)

==== 성능 튜닝 과정

[.text-center]
.자바 애플리케이션 성능 튜닝 과정
image::http://d2.naver.com/content/images/2015/06/helloworld-184615-1.png[]

=== Out Of Memory Error [http://ukja.tistory.com/61] +

[.text-center]
.Java Virtual Machine Model
image::http://www.nextree.co.kr/content/images/2016/09/JVM-1.jpg[Java Virtual Machine Model]

[.text-center]
.HotSpot JVM 구조와 영역별 Option
image::http://www.nextree.co.kr/content/images/2016/09/JVM-2.png[HotSpot JVM 구조와 영역별 Option]

* 보통 잘못된 코딩으로 인해 발생하게 되는 OOME의 대부분은 Permanent Space에서 발생

==== Java heap spac
* Heap size의 부족으로 Java Object를 Heap에 할당하지 못하는 경우. JVM 옵션 설정을 하지 않은 경우 많이 발생
* Java Heap의 크기가 작은 경우
* Memory Leak이 발생하는 경우
** Application Logic에 의한 Memory Leak
** JDK Bug나 WAS Bug에 의한 Memory Leak
** finalize 메소드에 의한 Collection 지연
* Object Allocation Profiling 수행

==== PermGen space
* Class나 Method 객체를 PermGen space에 할당하지 못하는 경우 발생하며 애플리케이션에서 너무 많은 class를 로드할 때 발생한다. 주로 잘못된 설계/구현에 의해 발생한다. -XX:PermSize, -XX:MaxPermSize Option을 이용하여 오류를 수정하기도 함
* 일반적으로 Class의 로딩은 시스템의 Class path에 의해서 로드된 Class 객체들과 에플리케이션 내 구현으로 다이나믹하게 로드되는 class들이 있는데 주로 문제는 애플리케이션 내 로직으로 다이나믹 하게 생성되는 Class들에 의해서 발생
* Class Loading 모니터링
** -verbose:gc: Loading되는 Class들을 Standard Out을 통해 출력해준다.
** Platform MBean: JMX 표준을 통해 제공되는 ClassLoadingMXBean API를 이용하면 프로그래밍적으로 Class Loading 정보를 얻을 수 있다.
** JConsole: JConsole을 이용하면 Class Loading 정보를 조회할 수 있다. JConsole은 JMX 클라이언트의 표준 샘플로 Platform MBean과 통신해서 Class Loading 정보를 얻는다.

==== Requested array size exceeds VM limit
* 사용할 배열의 사이즈가 VM에서 정의될 사이즈를 초과할 때 발생한다.

==== request bytes for . Out of swap space?
* Java는 런타임시 물리적 메모리를 초과한 경우 가상메모리를 확장해 사용하게 되는데 가용한 가상메모리가 없을 경우 발생

==== (Native method)
* JVM에 설정된 것 보다 큰 native메모리가 호출 될 때 발생
* Thread Stack Space가 부족한 경우
* Virtual Space Address가 소진된 경우
* Swap Space가 모자란 경우
* JNI Library에서 Memory Leak이 발생하는 경우
* 해소법
** Thread의 수를 줄인다. 동시에 수십개 이상의 Thread를 사용하는 것은 메모리의 문제 뿐만 아니라 지나친 Context Switching으로 인해 성능을 저하시키는 요인이 된다. Thread Pool 기법을 사용해서 동시 Thread의 수를 줄인다. 대부분의 WAS들이 Thread Pool 기법을 사용하고 있다.
** Thread Stack Size를 줄인다. 대부분의 OS에서 Thread Stack Size는512K ~ 1M이다. 만일 많은 수의 Thread가 필요한 Application이라면 Thread Stack Size를줄임으로써 OOME를 방지할 수 있다. 많은 경우 -Xss128k 정도나 -Xss256k 정도의 크기에서도 문제없이 작동한다.단, Stack Size가 줄어든 만큼 Stack Overflow Error가 발생할 확률은 높아진다.
** Java Heap 크기를 줄인다. 32bit Process가 사용 가능한 메모리 공간은 OS에따라 2G ~ 4G로 제한된다. 하나의 Java Process가 사용 가능한 공간은 [Java Heap+PermanentSpace+Native Heap]으로 이루어진다. 따라서 Java Heap이 지나치게 큰 공간을 사용하는 경우 NativeHeap에서 사용 가능한 공간이 줄어들게 된다. 따라서 Java Heap 크기를 줄이면 Native Heap의 메모리 부족에의한 OOME 문제를 해결 할 수 있다. 하지마 Java Heap 크기를 지나치게 줄이면 Java Heap 부족에 의한 OOME현상이 발생할 수 있으므로 유의해야 한다. Java Heap 크기를 줄이는 방법은 Thread Stack Space의 부족 문제뿐 아니라 Native Heap 부족에 의한 OOME 문제를 줄이는 공통적인 해결 방법이다.
** 64bit JVM을 사용한다. 64bit JVM에서는 32bit JVM Process가 가지는2G ~ 4G의 제한이 없다. 따라서 Native Heap의 메모리 부족 문제가 줄어든다. 이 방법 또한 Native heap부족에 의한 OOME 문제를 줄이는 공통적인 해결 방안이다.

==== Memory Dump
* jps
* jmap -dump:format=b,file=heap.hprof [Pid]
* jhat -J-mx512m heap.hprof

==== JDBC
* JDBC는 DBMS에 접근하기 위한 표준 API
* JDBC Type4 드라이버는 Java로만 작성되어 있으며(pure java), Java 애플리케이션에서 소켓을 이용해 DBMS와 통신

[.text-center]
.JDBC Type4 드라이버의 DBMS 통신 구조
image::http://d2.naver.com/content/images/2015/06/helloworld-1321-1.png[]

* Type4 드라이버는 소켓을 통해 바이트 스트림(byte stream)을 처리하기 때문에 HttpClient 같은 네트워크 라이브러리와 근본적으로 동작이 같음
* 많은 CPU자원을 소모
* ResponseTime의 손해
* 다른 네트워크 라이브러리가 가지고 있는 장애 포인트를 동일가짐
* HttpClient를 사용한 경험이 있다면 타임아웃 값을 제대로 설정하지 않아 장애(hang)가 발생
* Type4 드라이버 역시 SocketTimeout 값을 제대로 설정하지 않으면 동일한 장애가 발생

* WAS와 DBMS의 통신 시 타임아웃 계층

[.text-center]
.타임아웃 계층
image::http://d2.naver.com/content/images/2015/06/helloworld-1321-2.png[]

** 상위 레벨의 타임아웃은 하위 레벨의 타임아웃에 의존성을 가지고 있음
** 하위 레벨의 타임아웃이 정상으로 동작해야 상위 레벨의 타임아웃도 정상으로 동작
** 예를 들어, JDBC Driver SocketTimeout이 정상으로 동작하지 않으면, 그보다 상위 레벨의 타임아웃인 StatementTimeout과 TransactionTimeout도 정상으로 동작하지 않음
** StatementTimeout은 네트워크 연결 장애에 대한 타임아웃을 담당하는 것이 아니다. StatementTimeout은 Statement 한 개의 수행 시간을 제한하는 기능만 담당
** 네트워크 장애에 대비하는 타임아웃은 JDBC Driver SoecketTimeout이 처리
** JDBC Driver SocketTimeout은 OS의 SocketTimeout 설정에 영향을 받음
** JDBC Driver SocketTimeout을 설정하지 않아도 네트워크 장애 발생 이후 30분이 지나면 JDBC Connection Hang이 복구되는 것은 OS의 SocketTimeout 설정때문
** TransactionTimeout이란?
** StatementTimeout 이란?
* JDBC 드라이버의 StatementTimeout 동작 방식
** Oracle JDBC Statement의 QueryTimeout
** jTDS(Microsoft SQL Server) Statement의 QueryTimeout
** MySQL JDBC Statement의 QueryTimeout(5.0.8 버전)
** CUBRID JDBC Statement의 QueryTimeout
* JDBC 드라이버의 SocketTimeout 이란?
** JDBC 드라이버의 SocketTimeout 값은 DBMS가 비정상으로 종료되었거나 네트워크 장애(기기 장애 등)가 발생했을 때 필요한 값
* OS 레벨 SocketTimeout 설정

==== Commons DBCP 이해하기
* 데이터베이스와 애플리케이션을 효율적으로 연결하는 커넥션 풀(connection pool) 라이브러리는 웹 애플리케이션에서 필수 요소
* 커넥션 풀 라이브러리를 잘 사용하면 데이터베이스와 애플리케이션의 일부분에서 발생하는 문제가 전체로 전파되지 않게 할 수있음
* 일시적인 문제가 긴 시간 이어지지 않게 할 수 있음
* 반대로 값을 적절하지 못하게 설정해서 커넥션 풀이 애플리케이션에서 병목 지점이 되는 경우도 있음
* 웹 애플리케이션의 요청은 대부분 DBMS(database management system)로 연결되기 때문에 커넥션 풀 라이브러리의 설정은 전체 애플리케이션의 성능과 안정성에 영향을 미치는 핵심
* initialSize와 maxActive, maxIdle, minIdle 항목을 동일한 값으로 통일해도 무방
* 커넥션 개수와 관련된 가장 중요한 성능 요소는 일반적으로 커넥션의 최대 개수
* initialSize와 maxActive, maxIdle, minIdle 항목의 설정 값 차이는 성능을 좌우하는 중요 변수 아님
* maxActive 값은 DBMS의 설정과 애플리케이션 서버의 개수, Apache, Tomcat에서 동시에 처리할 수 있는 사용자 수 등을 고려해서 설정
=== Collection (Map)
* Collection

** List

**** ArrayList (List)
***** 내부 배열에 기반을 둔 리스트 구현
***** 리스트 요소에 대한 접근이 다른 리스트 기반 클래스보다 빠름
***** 요소가 삽입될 때 추가될 공간을 만들기 위해 객체를 이동시켜야 하고 삭제할 때는 삭제된 공간을 없애기 위해 요소들이 이동해야 하기 때문에 이동이 많아져 요소의 삽입과 삭제가 느림
***** 멀티쓰레드에 대한 동기화 안됨

**** Vector (List)
***** 멀티쓰레드에 대한 동기화

**** LinkedList (Queue, List)
***** 연결된 노드들을 기반으로 구현된 리스트
***** 리스트에 있는 요소를 접근하기 위해서는 링크를 통해 접근해야 하기 때문에 접근 속도가 느림
***** 노드에 대한 참조만을 변경하기 떄문에 삽입, 삭제 작업이 빠름

** Set

*** TreeSet (SortedSet, NavigableSet)
**** 트리 자료 구조를 기반으로 구현
**** 트리 자료 구조를 가지기 때문에 요소는 정렬된 저장
**** 요소에 접근하기 위해서는 반드시 링크를 통해야 하기 떄문에 접근 속도가 다른 Set 보다 느림

*** HashSet (Set)
**** 해쉬 테이블 자료 구조를 기반
**** 요소에 대한 정렬을 보장하지 않음
**** HashSet 은 TreeSet 보다 빠른 속도의 제공하며 null 참조가 저장되는 것을 허용

*** LinkedHasSet

*** EnumSet
**** 비트셋을 기반으로 구현
**** 저장되는 요소들은 열거형 Set 이 생성될 때 지정한 열거형에 포함되어 있는 상수
**** null 요소가 허용 안됨, null 요소를 저장하려고 하면 NullPointException

** Queue
*** 요소를 특정 순서로 지정하고 검색할 수 있는 컬렉션
*** AbstractQueue, ArrayBlockingQueue, ArrayDeque, ConcurrentLinkedDeque, ConcurrentLinkedQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue,
*** LinkedList, LinkedTransferQueue, PriorityBlockingQueue, PriorityQueue, SynchronousQueue

** Deque
*** 큐의 머리와 꼬리 부분 모두에서 삽입과 제거를 할 수 있는 더블 앤드 큐
*** ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque, LinkedList

* Map

** HashMap
*** 해쉬 테이블 자료 구조를 기반으로 하는 맵 구현
*** null 키와 값을 가진 항목을 허용하는데 항목이 저장되는 순서는 보장 하지 않음

** HashTable
*** 키와 값으로 null이 허용되지 않음
*** Thread safe

** LinkedHashMap
*** 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사
*** Map에 있는 엔트리들의 연결 리스트를 유지되므로 입력한 순서대로 반복 가능

** TreeMap (SortedMap)
*** 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장
*** 검색과 정렬에 적합한 컬렉션

** Properties (HashTable)
*** (String, String) 형태로 저장하는 보다 단순화된 컬렉션

** Java HashMap은 어떻게 동작하는가?
*** HashMap과 HashTable을 정의한다면, '키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array'

=== Thread
* Thread 란 : 시작점과 종료점을 가지는 일련된 하나의 작업 흐름
* Java 스레드는 데몬 스레드(Daemon Thread)와 비데몬 스레드(Non-daemon Thread)로 나눌 수 있음
* Thread 동기화의 종류
** synchronized : 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용하도록 보장
** volatile : 상호 배제성을 실현하지 않음, 어떤 스레드건 가장 최근에 기록된 값을 읽도록 보장
* 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없음

==== Thread Dump
* jstack
[source,java, indent=0]
jps -v
jstack [PID] > jstack.txt

* kill을 이용하는 방법
[source,java, indent=0]
ps -ef | grep java
kill -3 [PID]

* 분석
[source,java, indent=0]
"pool-1-thread-13" prio=6 tid=0x000000000729a000 nid=0x2fb4 runnable [0x0000000007f0f000]
java.lang.Thread.State: RUNNABLE

** "pool-1-thread-13" >> 쓰레드 이름
** prio=6 >> 우선순위
** tid=0x000000000729a000 nid=0x2fb4 runnable [0x0000000007f0f000] >> 쓰레드 ID
** java.lang.Thread.State: RUNNABLE >> 쓰레드 상태

==== 리플렉션
* 객체 리플렉션이란
** Java 클래스와 객체에 대한 정보를 프로그램 내에서 동적으로 알아낼수 있도록 하는 기능
* 리플렉션 작업
** 클래스 내부에서, 실행 시간에, 메서드와 필드에 대한 정보를 얻을 수 있음
** 어떤 클래스로부터 객체를 생성할 수 있음
** 객체 필드의 유요 범위가 어떻게 선언되어 있는냐에 관계없이, 그 필드에 대한 참조를 얻어내어 값을 가져오거나 설정
* 리플렉션 유용성
** 프로그램이 어떻게 동작하고 있는지에 대한 정보를 실행 시간에 관측하고 조정할 수 있도록 해줌
** 메서드나 생성자, 필드를 직접 접근할 수 있기 때문에 프로그램을 디버깅하거나 테스트 할 때 유용
** 호출할 메서드를 미리 알고 있지 않더라도 그 이름을 사용하여 호출할 수 있다

=== 버전별 변화
* 1.5
** Generic 도입, 향상된 for (foreach), Enum, Static Import, Metadata, Autoboxing / Unboxing, ThreadPool, Annotation
* 1.6
** Garbage First 및 성능 향상
* 1.7
** 다이아몬드(<>) 지시자 형식 유추
** String in Switch Statements :  Java 6 까지의 버전에서는 Switch-case 문에서 case 조건으로 판단할수 잇는 데이터 형은 원시형 데이터
** Multi-Exception catch, null 체크 방법 개선, Bracket Notation for Collection, 자동 자원 관리 (AutoCloseble), 숫자와 관련된 문자에 밑줄 표시, Path를 이용한 처리 (NIO), Fork와 Join
* 1.8
** Lambda Expression, Nashorn, Annotation 보안, OS Process Control
** Default Method Interface (default method, static method)
** Date API, Stream API, , Collection 에 Functional Programming
** 동시성 API 개선
** Permanent Generation 제거 (Metaspace)
* 1.9
** Modular System (Jigsaw), Java Shell, Stream 메소드 추가

== Spring

=== POJO (Plain Old Java Object)
* 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트

=== IoC(Inversion of Control) Container
* IoC 란 : 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴
* Bean : 스프링이 IoC 방식으로 관리하는 오브젝트
* Bean Factory : 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
* Application Context : Bean Factory 확장, 스프링이 제공하는 각종 부가 서비스를 추가 제공
* Configuration metadata : application context 혹은 bean factory 가 IoC를 적용하기 위해 사용하는 메타정보, 스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만 주로 bean 을 생성/구성하는 용도로 사용

=== DI [https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-collaborators]
* DI 란 : 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동적으로 연결해주는 것
* 종류
** 생성자를 이용한 의존성 주입 [https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-constructor-injection]
** Setter 메서드를 이용한 의존성 주입 [https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-setter-injection]
** 초기화 인터페이스를 이용한 의존성 주입

=== 클래스 호출방식 (IoC, DI)
[.center.text-center]
.일반적인 클래스 호출
image::https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F17363C3A4FAB775331E573[align="center", title-align="center"]

* 클래스내에서 선언과 구현이 한몸이기 떄문에 다양한 형태로 변화가 불가능

[.text-center]
.인터페이스를 이용한 클래스 호출
image::https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F18152F374FAB77F10E2007[align="center", title-align="center"]

* 클래스를 인터페이스와 구현클래스로 분리
* 구현클래스 교체가 용이하여 다양한 형태로 변화가 가능하지만 구현클래스 교체시 호출 클래스의 소스를 수정

[.text-center]
.팩토리패턴을 이용한 클래스 호출방식
image::https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F203486364FAB78FD1F9865[align="center", title-align="center"]

* 팩토리방식은 팩토리가 구현클래스를 생성하므로 클래스는 팩토리를 호출하는 코드로 충분
* 구현클래스 변경시 호출클래스에는 영향을 미치지 않고, 팩토리만 수정
* 하지만 클래스에 팩토리를 호출하는 소스가 들어가야한다. 그것 자체가 팩토리에 의존함을 의미

[.text-center]
.IoC를 이용한 클래스 호출 방식
image::https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164AC9354FAB798B07767C[align="center", title-align="center"]

* 팩토리패턴의 장점을 더하여 어떠한것에도 의존하지 않는 형태로 구성이 가능
* 실행 시점에 클래스간의 관계가 형성
* 즉 의존성이 삽입된다는 의미로 IoC를 DI(Dependency Injection) 라는 표현으로 사용

=== Bean Scope [https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch03s05.html]
* Singleton : 단일 Bean 정의를 Spring IoC 컨테이너별로 하나의 객체 인스턴스로 범위 지정
* Prototype : 단일 빈 정의를 원하는 수의 객체 인스턴스로 확장
* Request : 단일 Bean 정의를 단일 HTTP 요청의 라이프 사이클 범위로 범위 지정합니다. 즉, 각 HTTP 요청에는 단일 Bean 정의의 뒷면에서 작성된 Bean의 자체 인스턴스가 있습니다. 웹 인식 Spring ApplicationContext의 컨텍스트에서만 유효
* Session : 단일 Bean 정의를 HTTP 세션의 라이프 사이클 범위로 범위 지정합니다. 웹 인식 Spring ApplicationContext의 컨텍스트에서만 유효
* global Session : 단일 빈 정의를 전역 HTTP 세션의 라이프 사이클으로 범위 지정합니다. 일반적으로 포틀릿 컨텍스트에서 사용되는 경우에만 유효합니다. 웹 인식 Spring ApplicationContext의 컨텍스트에서만 유효

=== Spring Web MVC [http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html]
* DispatcherServlet : 클라이언트의 요청을 전달받는다. 컨트롤러에게 클라이언트의 요청을 전달하고, 컨트롤러가 리턴한 결과값을 View 에 전달하여 알맞은 응답을 생성하도록 함
* HandlerMapping : 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지를 결정
* HandlerAdapter : DispatcherServlet 의 처리 요청을 변환해서 컨트롤러에게 전달하고, 컨트롤러의 응답 결과를 DispatcherServlet 이 요구하는 형식으로 변환한다. 웹브라우저 캐시 등의 설정도 담당
* Controller : 클라이언트의 요청을 처리한 뒤 결과를 리턴한다. 응답 결과에서 보여줄 데이터를 모델에 담아 전달
* ModelAndView : 컨트롤러의 처리 결과를 정보 및 뷰 선택에 필요한 정보를 담음
* ViewResolver : 컨트롤러의 처리 결과를 보여줄 뷰를 결정
* View : 컨트롤러의 처리 결과를 화면을 생성한다. JSP나 Velocity 템플릿 파일 등을 이용해서 클라이언트에 응답 결과를 전송

[.text-center]
.The request processing workflow in Spring Web MVC
image::http://docs.spring.io/spring/docs/current/spring-framework-reference/html/images/mvc.png[]

[.text-center]
.Typical context hierarchy in Spring Web MVC
image::http://docs.spring.io/spring/docs/current/spring-framework-reference/html/images/mvc-context-hierarchy.png[]

[.text-center]
.Single root context in Spring Web MVC
image::http://docs.spring.io/spring/docs/current/spring-framework-reference/html/images/mvc-root-context.png[]

[.text-center]
.실행 흐름
http://cfs15.tistory.com/image/36/tistory/2008/12/09/05/39/493d85e8d96a0

* 처리 순서
** 클라이언트의 요청이 DispatcherServlet에 전달
** DispatcherServlet은 HandlerMapping을 사용하여 클라이언트의 요청이 전달될 Controller 객체를 구함
** DispatcherServlet은 Controller 객체의 handleRequest() 메소드를 호출하여 클라이언트의 요청을 처리
** Controller.handleRequest() 메소드는 처리 결과 정보를 담은 ModelAndView 객체를 리턴
** DispatcherServlet은 ViewResolver로부터 처리 결과를 보여줄 View를 구함
** View는 클라이언트에 전송할 응답을 생성

=== Spring ORM (Object Relational Mapping)

=== Spring Test
==== 유닛 테스트

=== AOP 구분

==== Spring AOP
* Spring AOP는 주어진 대상객체에 대한 프록시를 생성하는데 JDK 동적 프록시와 CGLIB를 모두 사용
* Spring AOP에서는 단지 DI의 도움을 받아 프록시 오브젝트를 추가함으로써 코드를 애스펙트를 적용

==== AspectJ
* 타킷 오브젝트 자체의 코드를 바꿈으로써 애스펙트를 적용
* 프록시를 사용하지 않음
* 타킷 오브젝트의 자바 코드에 처음부터 애스펙트가 적용되어 있던 것처럼 클래스 바이트코드를 변경하는 작업이 필요

== Software Pattern

=== OOP
* 객체지향 프로그래밍 이란 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고,
유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것

* 객체
** 우리가 표현할 수 있는 실세계의 모든 사물들
** 데이터를 가지고 있음
** 행위의 집합을 가지고 있음
** 개체를 구분하는 아이덴티를 가지고 있음
** 객체마다 자신만의 책임이 있음

* 클래스
** 객체를 생성하는 청사진
** 객체의 상태를 저장하는데 사용될 속성을 정의
** 객체가 이해할 수 있는 메세지와 메세지에 응답하는 과정을 정의
** 각각의 메세지에 대해 메소드 method 라고 불리우는 프로시저를 만들고, 구현

* 메세지
** 오퍼레이션의 실행을 요청하는 것

* 추상화
** 사람이 객체를 인식할 때 객체의 중요 특징을 추출해 내는데, 이 과정을 "추상화"
** 클래스를 만들 때는 구현하고자 하는 객체의 명사적인 특징만 뽑아내는 것이 아니라 객체가 가지는 동사적인 특징까지도 모두 뽑아내는 추상화 작업이 필요
** 명사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 변수가 탄생하고, 동사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 함수가 탄생
** 추상화 과정에서 주의해야 할 것이 있는데, 추상화 작업 시 앞으로의 확장성을 많이 고려해서 작업

* 캡슐화
** Don't Tell Ask 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라
*** 데미테르의 법칙
**** 메서드에서 생성한 객체의 메서드만 호출
**** 파라미터로 받은 객체의 메서드만 호출
**** 필드로 참조하는 객체의 메서드만 호출
** 멤버변수와 멤버함수를 모두 묶어서 하나의 단위 (클래스, 객체)로 만드는 일련의 작업
** 클래스의 내부가 바뀌어도 클래스를 참조하는 다른 클래스나 함수는 변경할 필요가 없음
** 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근
** 객체는 속성과 메소드로 만들짐 , 일부 속성과 메소드는 객체의 외부에서 접근 (interface) ,다른 속성,메소드는 객체 자신만의 사적인 용도로 예약되어 있고 이것을 구현 implement

* 다형성
** "같은 이름을 가겼으나, 다른 행동을 하는 것"
** 캡슐화, 상속과 함께 작동해서 객체-지향 프로그램의 흐름 제어 flow of control 를 단순화
** 예) "열다"의 경우 "문을 열다", "지갑을 열다", "지퍼를 열다", "파일을 열다" 이름은 같지만 상황에 따란 하는 여는 행동이 완전히 다른다는 것
** 객체 내에서 다형성이 발생 (미닫이 여닫이, Overload)
** 하나의 클래스 내부에 같은 이름을 가진 멤버 함수들이 존재하는 경우와 조상 클래스와 자손 클래스가 같은 이름을 가진 멤버 함수들을 가지는 경우 (Overloading, Overriding)
*** Overloading
**** 클래스의 메서드끼리 이름은 같은데 매개변수가 다르며 메서드 오버로딩이 일어남
**** 메서드를 호출할 때 어떤 메서드를 사용하지는 컴파일 할 때 결정
*** Overriding
**** 자식 클래스에 있는 인스턴스 메서드가 부모 클래스의 접근 가능한 메서드와 동일한 이름과 매개변수를 가지면 오버라이딩 함
**** 오버라이딩 되면 동적 디스패치가 가능해짐
**** 오버라이딩은 객체 지향 프로그램밍의 가장 핵심이 되는 기능

* 상속
** 조상 객체 생성기(클래스)의 모든 것이 후손 객체 생성기(클래스)에게 전달되는 것
** 코드의 재사용 보다 계층구조를 표현 하는 것 (IS-A 명확 할 때)

* 재사용
** 상속보단 조립
** 상속을 사용하면 상위 클래스에 구현된 기능을 그대로 재사용할 수 있기 때문에, 상속을 사용하면 재사용을 쉽게 할 수 있는 것은 분명 (문제가 많음)
*** 상위클래스 변경이 어려움, 클래스의 불필요한 증가, 상속의 오사용
*** 인터페이스르 재사용
**** 인터페이스를 사용하는 코드는 재사용 가능 (재사용)
***** 인터페이스 구현체 A가 있음 새로운 구현체 B 가 생기드라도 인터페이스를 사용하던 코드 로직(비즈니스)는 그대로 사용
**** 인터페이스 사용 시 변경이 안될는 일 없음, 테스트 하기 쉽다, 부가적인 기능 추가 수월

=== 추상클래스와 인터페이스의 차이
* 추상 클래스와 인터페이스는 상속받는 클래스 혹은 인터페이스 안에 있는 추상 메소드를 구현하도록 강제

** 추상클래스
*** 여러개의 가까운 클래스들 (is-a 관계가 형성될) 사이에 동일한 코드를 공유해서 사용 할 경우
*** 추상클래스를 상속한 클래스들이 많은 공통 메소드들과 필드와 public 보다 다양한 접근 제어자에 의해 사용 할 경우
*** non-static 과 non-final 필드를 선언하고 싶을때. 결과적으로 객체들의 상태를 메소드에서 접근하고 수정 할 수 있음

** 추상클래스 조건
*** 일반클래스보다 조금더 추상적은 개념의 것을 정의
*** 추상 메서드와 그냥 메서드, 멤버필드, 생성자를 정의 할 수 있지만, 추상메서드는 내용을 정의 할 수 없음
*** 추상메서드를 정의하면 추상클래스를 상속받은 클래스에서는 반드시 추상메서드를 Override 하여 정의
*** abstract class [클래스명] 으로 정의
*** 추상메서드는 [접근제한자] abstract [return 자료형] [메서드이름]() 으로 정의
*** extends 로 상속
*** 다중 상속이 안됨

** 인터페이스
*** 크게 상관없는(is-a 정도는 아닌 has-a 정도인) 클래스들이 너의 인터페이스를 구현( java8 부터는 구현된 것을 사용도 포함)해야 할 필요가 있을때. 예를들어 Comparable and Cloneable
*** 특정 데이터타입의 행위를 특별하게 구현하길 원할때 그러나 누가 그것의 행위를 구현 했는지에 대한 관심은 없을때
*** 다중 구현상속의 이점을 누려야 할때

** 인터페이스 조건
*** 추상클래스보다 훨씬 극단적이고 제한적인 성격을 가짐
*** 멤버필드와 추상메서드만 정의 할 수 있음
*** 상속받을려면 extends 를 사용하면 안되고 implements 를 사용하여야 함
*** 다중상속이 가능함
*** 추상메서드는 일반클래스의 메서드 형식과 같지만 몸통을 가질 수 없음
*** 선언은 interface [이름]으로 함

=== AOP
* 횡단 관심사의 모듈화, 분리 (애플리케이션의 여러 부분에 영향을 주는 기능)
** 횡단 관심사 : 한 애플리케이션의 야러 부분에 걸쳐 있는 기능을 가리켜 횡단 관심사
** 예) 보안은 하나의 애플리케이션내에서도 여러 객체 메소드의 보안 규칙에 영향을 미치는 횡단 관심사
* 어드바이스 : 애스펙트가 해야 할 작업, 무엇을 언제 할지 결정
* before, after, after-returing, after-throwing, around
* 조인 포인트 : 어드바이스를 적용할 수 있는 곳, 즉 조인 포인트는 애플리케이션 실행에 애스펙트를 끼워 넣을 수 있는 지점
* 포인트커트 : 애스펙트가 어드바이스할 조인 포인트, 한 애스펙트가 전체 애플리케이션의 모든 조인 포인트를 다 어드바이스 할 수는 없는 노릇
* 애스펙트 : 어드바이스 + 포인트커트 ((언제, 무엇), (어디서))
* 인트로덕션 : 기존 클래스에 코드를 변경 없이도 새 메소드나 멤버 변수를 추가 하는 기능
* 위빙 : 타킷 객체에 애스펙트를 적용해서 새로운 프록시 객체를 생성하는 절차
** compile time, classload time, runtime

=== SOLID
* Single Responsibility Principle : 단일책임의 원칙
** Single Responsibility Principle 란 클래스는 하나의 책임을 가져야하며 그 책임에 대한 이유로 변경되어야 한다.
** 책임 : '변경을 위한 이유', 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것
** 예시

[source,java, indent=0]
----
class Student {
  // 회사에서 일을 합니다.
  public void work() {
    ......
  }
  // 학교에서 공부를 합니다.
  public void study() {
    ......
  }
}
----

* Open Close Principle : 개방폐쇄의 원칙
** 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

* The Liskov Substitution Principle : 리스코브 치환의 원칙
** 서브 타입은 그것의 기반 타입으로 치환 가능해야 한다.

* Interface Segregation Principle : 인터페이스 분리의 원칙
** 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안 된다.

* Dependency Inversion Principle : 의존성역전의 원칙
** 상위 수준의 모듈은 하위 수준의 모둘에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
** 추상화는 구체적으로 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

=== 디자인패턴
* Iterator
** 복수의 요소가 모여 있는 집합에서 요소를 순서대로 저장해서 처리
* Adapter
** 서로 다른 인터페이스(API)를 갖는 클래스들을 연결
* Template Method
** 상위 클래스에서 처리의 뼈대를 세우고, 구체적인 처리를 하위 클래스에서 실행
* Factory Method
** 상위 클래스에서 인스턴스 작성법의 뼈대를 세우고, 구체적인 작성은 하위 클래스에서 실행
* Singleton
** 인스턴스가 하나만 존재

[source,java, indent=0]
----
public class Singleton {

	private volatile static Singleton singleton;
	private int ticket = 0;

	private Singleton() {
		System.out.println("Singleton 생성");
	}

	public static Singleton getInstance() {
		if(singleton == null) {
			synchronized (Singleton.class) {
				if(singleton == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}

	public int getNextTickerNumber() {
		return ticket++;
	}
}
----

* Prototype
** 모형이 되는 인스턴스를 복사해서 인스턴스를 만듬
* Builder
** 복잡한 인스턴스를 단계적으로 조립
* Abstract Factory
** 공장과 같이 부품을 조합해서 인스턴스 생성을 실행
* Bridge
** 2종류의 확장이 혼재하는 프로그램을 기능의 계층과 구현의 계층으로 분리하고, 그 사이를 연결
* Strategy
** 알고리즘을 전부 교체해서 수정하기 쉽도록 함
* Composite
** 그릇과 내용물을 동일시해서 재귀적인 구조를 구축
* Decorator
** 장식과 내용물을 동일시해서 장식을 여러 겹 중복되게 함
* Visitor
** 데이터 구조를 돌아다니면서 동일한 조작을 반복해서 적용
* Chain of Responsibility
** 복수의 오브젝트가 연결되어 있는 내부의 어딘가에서 일을 수행
* Facade
** 복잡하게 얽힌 클래스를 개별적으로 제어하는 것이 아니라, 창구 역할을 하는 클래스를 하나 배치해서 시스템 전체의 조작성을 좋게 함
* Mediator
** 복수의 클래스가 상호간에 직접 의사 소통을 하는 것이 아니라, 중개역을 하는 클래스를 하나 준비하고, 그 클래스하고만 의사 소통을 하게 해서 프로그램을 단순하게 만드듬
* Observer
** 상태가 변화하는 클래스와 그 변화를 통지받는 클래스를 분리해서 생각
* Memento
** 현재의 상태를 저장해 두고 필요할 때 복귀시키는 Undo 기능을 설정
* Stage
** 상태를 클래스로 표현하고 상태에 적합한 switch 문의 사용을 줄여줌
* Flyweight
** 복수의 장소에서 동일한 것이 등장할 때 그것들을 공유해서 낭비를 없앰
* Proxy
** 정말로 목적한 것이 필요하게 될 때까지 대리인을 사용해서 처리하는 진행
* Command
** 요구나 명령을 형태로 만들어서 클래스로 표현
* Interpreter
** 문법규칙을 클래스로 표현

=== 계층화 아키텍처(Layered architecture)

== 알고리즘 & 자료구조

=== 알고리즘이란?
* 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해놓은 명세서
* 용어
** 동적계획법 : 동적 계획법의 원리는 매우 간단하다. 일반적으로 주어진 문제를 풀기 위해서,
문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음,
그것을 결합하여 최종적인 목적에 도달하는 것이다. 각 하위 문제의 해결을 계산한 뒤,
그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다.
이러한 방법으로 동적 계획법은 계산 횟수를 줄일 수 있다.
특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다.

=== 자료구조란?
* 자료를 효율적으로 표현하고 저장, 처리하기 위해 정리하는 것
* 컴퓨터에서 사용할 자료를 더 효율적으로 저장하고 처리하기 위해서 자료의 특성과 사용 용도에 따라 분류하고 정리하는 것, 즉 구조화하는 것

=== 리스트
* 리스트라는 말은 원래 일람표, 목록, 명함을 의미
* 컴퓨터 공학에서는 요소를 순서대로 나열한 것을 리스트라고 부르며, 열 등으로 불림

=== 스택
* 삽입과 삭제가 리스트의 맨 처음에서만 이루어지는 것

[source,java, indent=0]
----
public class MyStack {

	Object[] stack;
	int stackSize;
	int sp;

	static int DEFAULT_STACK_SIZE = 100;

	public MyStack() {
		this(DEFAULT_STACK_SIZE);
	}

	public MyStack(int size) {
		stack = new Object[size];
		stackSize = size;
		sp = 0;
	}

	public void error(String s) {
		System.err.println(s);
		System.exit(1);
	}

	public void clear() {
		sp = 0;
	}

	public void push(Object x) {
		if (sp >= stackSize) {
			error("Stack Overflow");
		}
		stack[sp++] = x;
	}

	public Object pop() {
		if (sp <= 0) {
			error("Stack underflow");
		}
		return stack[--sp];
	}

	public boolean isEmpty() {
		return sp == 0;
	}

	public String toString() {
		String s;
		s = "MyStack = [";
		for (int i = 0; i < sp; i++) {
			s = s + stack[i];
			if (i < sp - 1) {
				s = s + ",";
			}
		}
		s = s + "]";
		return s;
	}

	public static void main(String[] args) {
		MyStack stack = new MyStack();
		stack.push("a");
		stack.push("b");
		System.out.println(stack);
		while (!stack.isEmpty()) {
			System.out.println("pop : " + stack.pop());
		}
		System.out.println("DONE! " + stack);
	}
}
----

=== 큐
* 삽입이 한쪽 끝에서만 이루어지고, 삭제는 반대쪽 끝에서만 이루어지는 리스트

[source,java, indent=0]
----
public class MyQueue {

	Object[] queue;
	int queueSize;
	int front;
	int rear;

	// 큐의 기본 크기
	static int DEFAULT_OUEUE_SIZE = 100;

	public MyQueue() {
		this(DEFAULT_OUEUE_SIZE);
	}

	public MyQueue(int size) {
		queueSize = size;
		queue = new Object[size];
		front = rear = 0;
	}

	public void error(String s) {
		System.err.print(s);
		System.exit(1);
	}

	public int next(int a) {
		return (a - 1) % queueSize;
	}

	public void clear() {
		front = rear = 0;
	}

	public void enqueue(Object x) {
		if (next(rear) == front) {
			error("이 이상 큐에 요소를 추가할 수 없습니다.");
		}
		queue[rear] = x;
		rear = next(rear);
	}

	public Object dequeue() {
		if (front == rear) {
			error("큐가 비어있기 때문에 요소를 꺼낼 수 없습니다.");
		}
		Object x = queue[front];
		front = next(front);
		return x;
	}

	public boolean isEmplty() {
		return front == rear;
	}

	public String toString() {
		String s;
		s = "MyQueue = [ ";
		for (int i = front; i != rear; i = next(i)) {
			s += queue[i] + " ";
		}
		s += "] front = " + front + " rear = " + rear;
		return s;
	}

	public static void main(String[] args) {
		MyQueue q = new MyQueue(5);
		q.enqueue("a");
		System.out.println(q);
	}
}
----

==== 연결 리스트
* 연결 리스트란 리스트에 포함된 각 요소들을 링크로 이어 붙인 것

=== 탐색
* 탐색이란 표에서 어떤 특정한 값을 가지는 자료를 찾아내는 조작

==== 선형 탐색
* 검색 복잡도 : O(n)
* 등록 복잡도 : O(1)

[source,java, indent=0]
----
public class LinearSearch {

	class Entry {
		int 	key;
		Object	data;

		public Entry (int key, Object data) {
			this.key = key;
			this.data = data;
		}
	}

	final static int MAX = 100;
	Entry[] table = new Entry[MAX];
	int n = 0;

	public void add(int key, Object data) {
		if(n >= MAX) {
			System.out.println("AAAA");
			System.exit(1);
		}
		table[n++] = new Entry(key, data);
	}

	public Object search(int key) {
		int i;
		i = 0;
		while (i < n) {
			if(table[i].key == key) {
				return (table[i].data);
			}
			i++;
		}
		return null;
	}
}
----

==== 이진 탐색
* 검색 복잡도 O(log n)
* 등록 복잡도 O(n)

[source,java, indent=0]
----
class Entry {
	int key;
	Object data;

	public Entry(int key, Object data) {
		this.key = key;
		this.data = data;
	}
}

public class BinarySearch {

	final static int MAX = 9999999;
	Entry[] table = new Entry[MAX];
	int n = 0;

	public Object search(int key) {
		int low = 0, high, middle;
		high = n - 1;

		while (low <= high) {
			middle = (low + high) / 2;
			if (key == table[middle].key) {
				return table[middle].data;
			} else if (key < table[middle].key) {
				high = middle - 1;
			} else {
				low = middle + 1;
			}
		}
		return null;
	}

	public static void main(String[] args) {
		BinarySearch bs = new BinarySearch();
		bs.table[0] = new Entry(0, "Data0");
		bs.table[1] = new Entry(1, "Data1");
		bs.table[2] = new Entry(2, "Data2");
		bs.n = 3;
		System.out.println(bs.search(2));
	}
}
----

==== 해싱
* 해싱이란 키 값을 배열로 첨자로 변환하는 함수(해시 함수라고 부른다)를 이용하여 고속 탐색을 수행하는 알고리즘
* 체인화 : 같은 해시 값을 가지는 데이터를 연결 리스트로 연결해 가는 방법
* 오픈 어드레스 : 충돌이 발생하였을 때 미리 정해 둔 절차에 따라 다른 버킷에 데이터를 저장 (재해싱)

=== 정렬

==== 퀵 소트 O(n2), O(lg2)

=== 빅오표기법 (time complexity, space complexity)
* 시간 복잡도(Time Complexity) : 알고리즘의 수행시간 분석결과
* 공간 복잡도(Space Complexity) : 알고리즘의 메모리 사용량에 대한 분석결과
* 비교 : O(1) < O(Logn) < O(n) < O(nLogn) < O(n^2) < O(n^3) < O(2^n)
* 최고차항만 생각하여 계산    ex) n^2 + n +3 = O(n^2)

[.text-center]
.Big-O Complexity
image:http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2561B14456AE53DF246309[]

=== ETC
* AVL-TREE
** AVL 트리(AVL tree)는 가장 초기에 나온 균형 잡힌(balanced) 이진 탐색 트리이다. 1962년 G.M. Adelson-Velskii와 E.M. Landis 가 그들의
논문 "An algorithm for the organization of information"[1] 을 통해 발표했고 그들의 이름을 따서 지어졌다.
AVL 트리는 각각의 노드(node, 분기점)마다 왼쪽과 오른쪽 부분 트리(sub-tree)의 높이 차이에 대한 정보를 가지며 부분 트리의 높이 차이가 1보다 크지 않은 성질을 가진다.
균형 잡힌 AVL 트리는 n개의 원소가 있을 때 O(log n) 의 시간복잡도로 검색, 삽입, 삭제를 할 수 있다.
그러나 삽입과 삭제를 할 때에는 원하는 노드를 찾기 위해 2개의 경로가 필요하기 때문에 레드-블랙 트리 만큼 효율이 좋지 않아 자주 쓰이지는 않는다.[2]
* Red-Black Tree
** 레드-블랙 트리는 자가 균형 이진 탐색 트리(self-balancing binary search tree)로써, 대표적으로는 연관 배열 등을 구현하는 데 쓰이는 자료구조이다.
최초의 구조는 1972년 루돌프 바이어가 창안했으며, 이를 "대칭형 이진 B-트리"라고 불렀고, 1978년 레오 귀바스(Leo J. Guibas)와 로버트 세지윅이 발표한 논문에서 레드-블랙 트리라는 이름이 등장하게 되었다.
레드-블랙 트리는 복잡한 자료구조이지만, 실 사용에서 효율적이고, 최악의 경우에도 상당히 우수한 실행 시간을 보인다: 트리에 n개의 원소가 있을 때 O(log n) 의 시간복잡도로 삽입, 삭제, 검색을 할 수 있다.

== 운영체제
=== 프로세스
=== 스레드
=== 메모리

== 네트워크
=== TCP
* TCP 3-WAY HAND SHAKING
** TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미
** 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 함
** 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 함
** 과정
*** A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.
*** B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
*** A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.

=== Http
* Method
** GET
*** idempotent
*** 서버에게 리소스를 달라고 요청하기 위해 쓰임
*** HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구
** HEAD
*** 정확히 GET 처러 행동하지만, 서버는 응답으로 헤더만을 돌려줌 (엔터티 본문 X)
*** 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
*** 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
*** 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
** PUT
*** 서버에서 문서를 씀
*** 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해줌
*** 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
*** 콘텐츠를 변경할 수 있게 해주기 떄문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구
** POST
*** non-idempotent
*** 서버에 입력 데이터를 전송하기 위해서 설계
** TRACE
*** 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
** OPTION
*** 웹 서버에게 여려 가지 종류의 지원 범위에 대해서 물어봄
** DELETE
*** 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
* Restful API
** Representational State Transfer 라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개
** REST는 요소로는 크게 리소스,메서드,메세지 3가지 요소로 구성

== 데이터베이스

=== 모델링

* 모델링이라는 단어는 실체를 나타내는 일과 모형화라는 의미로 해석된다.
‘실체를 나타낸다’의 의미는 ‘대상을 나타낸다’라는 말로 해석될 수도 있다.
모형화라는 의미는 ‘형태를 만드는 일’ 혹은 ‘대상을 만드는 일’이라고 해석할 수 있다.
따라서 데이터 모델링이란 사용자의 요구사항으로부터 데이터의 실체를 나타내는 일이라고 해석할 수 있을 것이다.

=== RDBMS
=== 성능 향상을 위한 SQL 작성법
* 인덱스 키의 크기는 되도록 작게 설계해야 성능에 유리하다.
* 분포도가 좋은 칼럼(좁은 범위), 기본 키, 조인의 연결 고리가 되는 칼럼을 인덱스로 구성한다.
* 단일 인덱스 여러 개보다 다중 칼럼 인덱스의 생성을 고려한다.
* 업데이트가 빈번하지 않은 칼럼으로 인덱스를 구성한다.
* JOIN 시 자주 사용하는 칼럼은 인덱스로 등록한다.
* 되도록 동등 비교(=)를 사용한다.
* WHERE 절에서 자주 사용하는 칼럼에는 인덱스 추가를 고려한다.
* 인덱스를 많이 생성하는 것은 INSERT/UPDATE/DELETE의 성능 저하의 원인이 될 수 있다.
* 인덱스 스캔이 테이블 순차 스캔보다 항상 빠르지는 않다. 보통 선택도(selectivity)가 5~10% 이내인 경우에 인덱스 스캔이 우수하다.

== ETC

=== 마이크로서비스

* 작고 자율적으로 협업하는 서비스를 의미함

==== 이점

* 기술 이기종성
  ** 다수의 협업 서비스로 구성된 시스템에서 각 서비스가 다른 기술을 사용하도록 결졍할 수 있음
* 회복성
  ** 한 시스템의 컴포넌트에 장애가 발생하더라도 그 장애가 전파되지 않는다면 해당 문제를 격리하고 나머지 시스템을 계속 작동 시킬 수 있음
* 확장성
  ** 모놀리식 애플리케이션에 묶여 있다면 전체를 한 덩어리처럼 확장해야 함 그러나 작은 서비스들로 구성되어 있다면 필요한 서비스만 확장할 수 있음
* 배포 용이성
* 조직 부합성
* 조합성
* 대체 가능성을 위한 최적화

=== Domain Driven Design

* 대다수 소프트웨어 프로젝트에서는 초점을 도메인과 도메인 로직에 맞춰야 한다.
* 복잡한 도메인 설계는 모델을 기반으로 삼아야 한다.
* DDD는 기술이나 원칙이 아님 이것은 사고하는 방법이며, 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트의 진행 속도를 높이는 데 중요시해야 할 것들의 모음

[.text-center]
.도메인 주도 설계의 흐름을 한눈에 파악할 수 있는 다이어그램
image:http://cfile1.uf.tistory.com/image/127825564E375F7D0E7358[]

==== Entity
* 속성이 아닌 식별성을 기준으로 정의되는 도메인 객체
* 예) DB : ERD (Entity-Relationship Model), J2EE : Entity Bean

==== Value Object
* 식별성이 아닌 속성을 이용해 정의되는 불변 객체
* 모든 것에 식별성을 부여하고 Entity로 관리한다면 복잡성 증가
* 과거 Java의 DTO(Data Transfer Object) 패턴의 Value Object와 관계없음
* Entity와 Value Object을 구별하는 첫 번째 조건은 식별성
* 식별셩을 가지면 Entity 그렇지 않으면 Value Object

==== Service
* Domain Object에서 위치시키기 어려운 operation을 가지는 객체
* 여러 Domain Object 다루는 연산 Service의 오퍼레이션을 일반적으로 Stateless
* Domain Object에 해당하는 역할을 Service Operation으로 만드는 경우 도메인 역할을 침범하여 강 결합이 일어남

==== Module
* 유사 작업 및 개념을 그룹화 하여 복작도를 감소시키는 기법
* 응집도가 높은 모듈은간의 관계는 약 결합
* Java로 구현하는 경우 Package로 구성될 수 있다.

==== Aggregate
* 연관된 Entity와 Value Object의 묶음. 일관성과 트랜잭션, 분산의 단위, 캡슐화를 통한 복잡성 관리
* 예를 들어 쇼핑몰 사이트에서 주문 Entity 내에 배송주소 정보를 우편번호, 주소1, 주소2, 상세주소, 이런식으로 각 칼럼으로 정의하는 것이 아니라,
주소라는 Value Object를 별도로 작성하고 주문 Entity는 주소 Value Object을 포함하는 방식으로 관계 일관성 및 단순성화를 유지한다.

==== Factory
* 복잡한 Entity의 생성 절차에 캡슐화 할 수 있는 개념
* 생성하기 복잡한 Aggregate내의 여러 객체를 동시에 생성
* 생성시 Aggregate의 일관성 유지

==== Repository
* 도메인 영역과 데이터 인프라스트럭쳐 계층의 분리하여 데이터 계층에 대한 결합도를 낮추기 위한 방안
* 생성된 Aggregate에 대한 영속성 관리, 조회, 등록, 수정, 삭제시 Aggregate의 일관성 유지
* DB및 데이터 저장소의 데이터를 조회하고 저장하는 경우 Repository를 활용한다.

==== Bounded Context
* 각각의 업무는 분할된 컨텍스트로 나눌 수 있으며 각 Context에 사용되는 모델은 서로 분리되어야 하며, 각 하나의 Context는 하나의 팀에 할당되어 관리되는 것이 좋다.
또한 이러한 방향은 Micro Service Architecture에서 추구하는 방향이기도 하다.

=== 시스템 성능 최적화

==== 개선 방향성
1. 병렬/분산 처리
* 화면 내 서비스 요청을 병렬로 처리할 수 있는가?
* 서버 내 오래 걸리는 작업들을 병렬로 처리할 수 있는가?
* 웹 서버, 애플리케이션 서버의 작업 스레드 풀과 DB 연결 풀 등 병렬 자원을 늘릴 수 있는가?
* 트랜잭션이 집중되는 테이블은 파티션으로 분산할 수 있는가?
* DB를 분산 저장(Sharding)해서 사용자 요청을 분산할 수 있는가?
* 파일 입출력을 분산해 병렬 처리할 수 있는가?
2. 비동기 처리
* 화면에서 처리시간이 오래 걸리는 항목을 비동기 처리할 수 있는가?
* 온라인 서비스에 필수 작업 이외에 부가 기능을 후행 처리할 수 있는가?
* 디스크 입출력을 비동기 처리할 수 있는가?
* 업무 처리와 로깅 작업을 비동기로 분리할 수 있는가?
3. 캐시
* 반복 사용되는 DB 조회 결과를 캐시할 수 있는가?
* 반복되는 계산 값을 캐시할 수 있는가?
* 프레임워크와 애플리케이션 로직에서 사용하는 기초 데이터를 캐시됐는가?
* 상품 팩토리처럼 변경주지가 길고, 빈도는 낮은 기준 정보를 캐시할 수 있는가?
* 화면 콘텐츠 변경이 빈번하지 않다면 캐시할 수 있는가?
* 게시판 목록 같은 포털 메인 화면의 일부를 캐시할 수 있는가?
4. 집합처리
* 처리 건수가 많은 DB DML은 집합 처리하고 있는가?
* DB Fetch 건수는 적절한가?
* 파일을 읽고 쓸 때 레코드 단위로 처리하는가? 파일을 읽고 쓴느 단위가 너무 작지 않은가?
* 네트워크 데이터는 대량으로 송수신하고 있는가?
* 웹 화면에서 HTTP 호출 수를 줄일 수 있는가? (애플리케이션 턴 수를 줄일 수있는가?)
5. 오버헤드 제거
* 필요한 결과를 얻기 위한 최적화된 로직인가?
* 불필요하게 수행되는 쿼리나 로깅이 없는가?
* 업무 로직에서 필요 이상의 DB 데이터를 조회 하는가?
* 스레드 내 또는 스레드 간에 반복 수행되는 기능을 제거할 수 있는가?
* 필요 이상으로 크케 설정된 자원이 존재하는가?
6. 경합 제거
* 배타적으로 락을 획득해서 수행하는 코드는 락 범위가 필요한 부분만으로 최소화됐는가?
* 업무 처리 단계에서 DB 락을 최소화하도록 경합 DML이 로직 뒤에 위치하는가?
* 로그 파일에 경합이 발생하고 있는가?
7. SQL 개선
* 실행계획은 적절한가? (적절한 인덱스를 사용하고 있는가? 전체 테이블을 탐색하는 SQL이 존재하는가?)
* 주기적으로 테이블 통계가 갱신되고 있는가?
* SQL의 바인드 변수 처리는 잘 돼 있는가?
8. 송수신 효율화
* 송수신 전문은 네트워크 특성을 고려해 적절한 크기를 가지는가?
* 네트워크 턴 수를 줄일 수 있는가?
* 압축해서 전송할 수 있는가?
* 전송하는 이미지는 크기를 최소화하는 이미지 품질과 포맷을 가지고 있는가?
* 네트워크 전송 품질(RTT, 재전송)을 개선할 수 있는가?
9. 자원 사용 효율화
* CPU를 많이 사용하는 함수를 개선 또는 대체할 수 있는가?
* 메모리 사용량을 줄일 수 있는가?
* 불필요한 파일 입출력을 제거할 수 있는가?
* 메모리 누수를 제거할 수 있는가?
* 자바 GC를 효율적으로 수행할 수 있는가?
* 자바 GC를 효율화하기 위해 메모리 사용 패턴을 개선할 수 있는가?
10. 물리적인 자원 증설
* CPU, 디스크, 메모리 등 서버 자원 중에서 증설이 필요한 자원이 있는가?
* 보다 고성능 스토리지로 교체할 필요성이 있는가?
* 스토리지와 서버 간 입출력 개선을 위해 채녈 수를 늘릴 필요가 있는가?
* 네트워크 대역폭은 여유가 있는가?

=== TDD

== Q&A

=== Q1 : 쓰레드와 프로세스의 차이는?
* 프로세스와 쓰레드는 서로 관계가 있으나 기본적으로는 다르다.
프로세스는 실행되고 있는 프로그램 개체이다.
**프로세스는 CPU 시간이나 메모리 등이 시스템 자원이 할당되는 독립적인 객체**이다.
각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 할 수 없다.
어떤 프로세스는 다른 프로세스의 자원을 접근하려면 프로세스 간 통신(IPC)을 사용하여야 한다.
프로세스간 통신 방법으로는 파이프나 파일, 소켓 등이 있다.
쓰레드는 프로세스와 같은 스택 공간을 사용하며, 여러 쓰레드는 그 상태의 일부를 서로 공유한다.
통상 같은 메모리를 읽고 쓰는 여러 프로세스를 생성 할 수 있다.
프로세스가 다른 프로세스의 메모리를 읽고 쓰는 여러 프로세스를 생성 할 수 있다.
프로세스가 다른 프로세스의 메모리를 직접적으로 접근할 수 없는 것과는 다르다.
그러나 각각의 쓰레드에는 별도의 레지스터와 스택이 배정된다.
다른 쓰레드가 해당 스택 메모리를 읽고 쓰는 것은 허용된다.
쓰레드는 프로세스의 특정한 수행 경로다.
한 쓰레드가 프로세스 자원을 변경하면, 다른 이웃 쓰레드도 그 변경 결과를 즉시 볼 수 있다.

== 참고
* http://d2.naver.com/helloworld/1230 [JVM Internal]
* http://d2.naver.com/helloworld/1321 [JDBC Internal - 타임아웃의 이해]
* http://d2.naver.com/helloworld/1329
* http://d2.naver.com/helloworld/6043
* http://d2.naver.com/helloworld/10963
* http://d2.naver.com/helloworld/37111
* http://d2.naver.com/helloworld/184615
* http://d2.naver.com/helloworld/329631
* http://d2.naver.com/helloworld/1326256
* http://isstory83.tistory.com/m/91

= 학이시습지 불역열호 유붕자원방래 불열락호 인부지이불온 불역군자호