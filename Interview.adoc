= Interview
:source-language: java
:source-highlighter: pygments

== Java

=== 추상클래스와 인터페이스의 차이
    * 추상 클래스와 인터페이스는 상속받는 클래스 혹은 인터페이스 안에 있는 추상 메소드를 구현하도록 강제한다.

=== 용어
    * Overloading
        ** 클래스의 메서드끼리 이름은 같은데 매개변수가 다르며 메서드 오버로딩이 일어남
        ** 메서드를 호출할 때 어떤 메서드를 사용하지는 컴파일 할 때 결정

    * Overriding
        ** 자식 클래스에 있는 인스턴스 메서드가 부모 클래스의 접근 가능한 메서드와 동일한 이름과 매개변수를 가지면 오버라이딩 함
        ** 오버라이딩 되면 동적 디스패치가 가능해짐
        ** 오버라이딩은 객체 지향 프로그램밍의 가장 핵심이 되는 기능

    * Hiding
        ** 부모 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스와 동일한 이름으로 자식 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스의 이름을 만들면, 자식에서 만든 요소가 부모에 있는 요소를 하이딩함

    * Shadowing
        ** 변수, 메서드, 클래스, 인터페이스의 이름을 같은 영역에서 동일하게 사용하면 이름이 겹쳐 새도윙이 발생
        ** 어떤 대상이 섀도윙되면, 해당 대상을 이름으로 접근할 수 없음

    * Deep copy, Shallow Copy
        ** 배열이나 객체를 복사할 때 단순히 참조만 복사하는 것을 shallow copy, 원본과 같은 데이터를 저장하고 있는 새로운 객체나 배열을 생성하는 것은 deep copy 라고 한다.

    * 접근제한자

        ** 종류
            *** default : 같은 패키지(폴더)에 있는 객체들만 허용
            *** public : 모든 접근을 허용
            *** private : 현재 객체 내에서만 허용
            *** protected : 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용

        ** 사용
            *** 클래스 : public, default
            *** 생성자 : public, protected, default, private
            *** 멤버변수 : public, protected, default, private
            *** 멤버메소드 : public, protected, default, private
            *** 지역변수 : 접근제한자 사용 불허

=== 가비지컬렉션
    ** JVM 구조

=== Collection

=== 멀티쓰레드
    * 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없음
    * Thread 동기화의 종류
        ** synchronized : 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용하도록 보장
        ** volatile : 상호 배제성을 실현하지 않음, 어떤 스레드건 가장 최근에 기록된 값을 읽도록 보장

=== 버전별 변화
    * 1.5
        ** Generic 도입
        ** 향상된 for (foreach)
        ** Enum
        ** Static Import
        ** Metadata
        ** Autoboxing / Unboxing
        ** ThreadPool
        ** Annotation
    * 1.6
        ** Garbage First
     * 1.7
        ** 다이아몬드(<>) 지시자 형식 유추
        ** String in Switch Statements :  Java 6 까지의 버전에서는 Switch-case 문에서 case 조건으로 판단할수 잇는 데이터 형은 원시형 데이터
        ** Multi-Exception catch
        ** null 체크 방법 개선
        ** Bracket Notation for Collection
        ** 자동 자원 관리 (AutoCloseble)
        ** 숫자와 관련된 문자에 밑줄 표시
        ** Path를 이용한 처리 (NIO)
        ** Fork와 Join
     * 1.8
        ** Lambda Expression
        ** Nashorn
        ** Annotation 보안
        ** OS Process Control
        ** Default Method Interface (default method, static method)
        ** Date API, Stream API, , Collection 에 Functional Programming
        ** 동시성 API 개선
        ** Permanent Generation 제거 (Metaspace)
     * 1.9
        ** Modular System (Jigsaw)
        ** Java Shell
        ** Stream 메소드 추가
        ** System.in Static

== Spring

=== IoC container
    * 스프링에서는 스프링이 제어권을 가지고, 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 한다.
    * 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 IoC가 적용된 오브젝트를 가리킨다.
    * 스프링에서는 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC오브젝트를 빈 팩토리라고 부른다.(= 어플리케이션 컨텍스트)
=== DI
    * 인터페이스를 구현한 구체적인 클레스를 인터페이스에 할당하는 것.
    * 의존관계를 주입시켜준다.

=== DispatcherServlet

== Software Pattern

=== OOP

* 캠슐화
** 항상 은닉화를 전제, 관련이 있는 데이터 그리고 동작들을 하나로 묶어 요약하고 사용자에게는 내부적인 접근을 허용하지 않는 대신에 사용의 편의성을 제공해 주는 것

* 추상화
** 사람이 객체를 인식할 때 객체의 중요 특징을 추출해 내는데, 이 과정을 "추상화"라고 한다.
** 클래스를 만들 때는 구현하고자 하는 객체의 명사적인 특징만 뽑아내는 것이 아니라 객체가 가지는 동사적인 특징까지도 모두 뽑아내는 추상화 작업이 필요
** 명사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 변수가 탄생하고, 동사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 함수가 탄생
** 추상화 과정에서 주의해야 할 것이 있는데, 추상화 작업 시 앞으로의 확장성을 많이 고려해서 작업

=== AOP
    * 관심사의 분리를 통해 비즈니스 로직과 횡단관심사의 보조기능을 분리하기 위함.
    * 어드바이스를 포인트컷에 위빙한다고 표현함(Weaving)
    * 위빙(Weaving)이란? : 포인트컷에 의해 결정된 조인포인트에 어드바이스를 삽입하는 과정
      ** 로그를 찍는다거나, 보안과 관련된 부분은 코드 곳곳에 나타나게됨.
      ** 이러한 관심사를 분리하기 위해서 AOP가 나타남.
      ** 메인 프로그램의 비즈니스 로직으로부터 2차적 또는 보조 기능들을 고립시키는 프로그래밍 패러다임.
      ** 횡단관심사의 분리를 가능하게 함.
    * 어드바이스 : 부가기능을 구현한 클래스를 빈으로 등록한 것
    * 포인트컷 : 부가기능이 실행되어야 하는 부분. 많은 조인 포인트들 중 특정 부분을 의미.
    * 어드바이저 : 어드바이스와 포인트컷을 묶어놓은 것.

=== SOLID
* Single Responsibility Principle : 단일책임의 원칙
** Single Responsibility Principle 란 클래스는 하나의 책임을 가져야하며 그 책임에 대한 이유로 변경되어야 한다.
** 책임 : '변경을 위한 이유', 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것
** 예시
[source,java, indent=0]
class Student {
  // 회사에서 일을 합니다.
  public void work() {
    ......
  }
  // 학교에서 공부를 합니다.
  public void study() {
    ......
  }
}

* Open Close Principle : 개방폐쇄의 원칙
** 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

* The Liskov Substitution Principle : 리스코브 치환의 원칙
** 서브 타입은 그것의 기반 타입으로 치환 가능해야 한다.

* Interface Segregation Principle : 인터페이스 분리의 원칙
** 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안 된다.

* Dependency Inversion Principle : 의존성역전의 원칙
** 상위 수준의 모듈은 하위 수준의 모둘에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
** 추상화는 구체적으로 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

=== 디자인패턴

== 알고리즘 & 자료구조

=== 알고리즘이란?
 * 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해놓은 명세서

=== 자료구조란?
 * 자료를 효율적으로 표현하고 저장, 처리하기 위해 정리하는 것
 * 컴퓨터에서 사용할 자료를 더 효율적으로 저장하고 처리하기 위해서 자료의 특성과 사용 용도에 따라 분류하고 정리하는 것, 즉 구조화하는 것

=== 선형 리스트

=== 큐

=== 스택

=== 해시 테이블

=== ETC
 * AVL-TREE
 * Red-Black Tree

== 운영체제
=== 프로세스
=== 스레드
=== 메모리

== 네트워크
=== TCP
    * TCP 3-WAY HAND SHAKING
        ** TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미
        ** 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 함
        ** 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 함
        ** 과정
            *** A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.
            *** B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
            *** A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.

=== Http
    * Method
        ** GET
            *** idempotent
            *** 서버에게 리소스를 달라고 요청하기 위해 쓰임
            *** HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구
        ** HEAD
           *** 정확히 GET 처러 행동하지만, 서버는 응답으로 헤더만을 돌려줌 (엔터티 본문 X)
           *** 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
           *** 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
           *** 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
        ** PUT
            *** 서버에서 문서를 씀
            *** 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해줌
            *** 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
            *** 콘텐츠를 변경할 수 있게 해주기 떄문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구
        ** POST
            *** non-idempotent
            *** 서버에 입력 데이터를 전송하기 위해서 설계
        ** TRACE
            *** 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
        ** OPTION
            *** 웹 서버에게 여려 가지 종류의 지원 범위에 대해서 물어봄
        ** DELETE
            *** 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
    * Restful API
        ** Representational State Transfer 라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개
        ** REST는 요소로는 크게 리소스,메서드,메세지 3가지 요소로 구성
== Q&A

Q1 : 장애대응
A1 :

Q2 : DB
A1 :

Q3 : MSA 에서 Distributed Transaction
A3 :

Q4 : 1000 * 1000 셀에 한가지 셀에 1000가지 색이 들어 갈때 필요한 메모리의 양
A4 : 한셀에 1000가지 색이 들어간다면 한셀에 필요한 비트수는 2^10 = 1024 로 유도하며 품

Q5 : 문자열로 된 숫자 Int 변환
A5 :
[source,java, indent=0]
public static int StringToInt(String str) {
		int i = 0, num = 0, sign = 1;
		char[] c = str.toCharArray();

		if (c[i] == '-') {
			i++;
			sign = -1;
		}

		while (i < c.length) {
			num *= 10;
			num += c[i] - '0';
			i++;
		}

		return num * sign;
	}

Q6 : 0 ~ 1000의 숫자중 중복 가능하게 1000개의 숫자를 뽑았을때, 이들 중 중간값
A6 : 카운팅 소트, 1000개의 변수를 갖는 배열, 숫자 값을 인덱스 , 해당 숫자가 나올떄마다 해당 변수의 값을 증가, 갯수를 앞에서부터 더해 500 이상, 지점의 인덱스

Q8 : Singleton Multi Thread 고려해서 구현

Q9 : 써본 DB가 뭐고 장단점 들을 말해보라

=== 빅오표기볍 (시간, 공간)