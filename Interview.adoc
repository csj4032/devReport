= Interview
:source-language: java
:source-highlighter: pygments

== Java

=== 기본형
    * 논리형 : true, false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용
        ** boolean : 1byte (false, true)
    * 문자형 : 문자를 저장하는데 사용되며, 변수 당 하나의 문자만을 저장할 수 있음
        ** char : 2byte (u0000~uffff 0~2^16)
    * 정수형 : 정수 값을 저장하는 데 사용된다 주로 사용되는 것은 int, long
        ** byte : 1byte (128 ~ 127 -2^7~2^7)
        ** short : 2byte (128 ~ 127 -2^15~2^15-1)
        ** int : 4byte (128 ~ 127 -2^31~2^31-1)
        ** long : 8byte (-2^63~2^63-1)
    * 실수형 : 실수 값을 저장하는데 사용됨 float, double
        ** float : 4byte
        ** double : 8byte

=== String, StringBuffer, StringBuilder 차이
 * String : Immutable(불변) String 클래스의 객체는 Heap 상에 생성될 경우 한번 생성된 객체는 내부 내용을 변경 할 수 없음
 * StringBuffer : Thread Safe
 * StringBuilder : Thread Safe X

=== 용어

* Thread Safe : 여러 쓰레드에 의해 코드가 실행되더라도 실행 결과의 보장

* Hiding
** 부모 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스와 동일한 이름으로 자식 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스의 이름을 만들면, 자식에서 만든 요소가 부모에 있는 요소를 하이딩함

* Shadowing
** 변수, 메서드, 클래스, 인터페이스의 이름을 같은 영역에서 동일하게 사용하면 이름이 겹쳐 새도윙이 발생
** 어떤 대상이 섀도윙되면, 해당 대상을 이름으로 접근할 수 없음

* Deep copy, Shallow Copy
** 배열이나 객체를 복사할 때 단순히 참조만 복사하는 것을 shallow copy, 원본과 같은 데이터를 저장하고 있는 새로운 객체나 배열을 생성하는 것은 deep copy 라고 한다.

* 접근제한자

** 종류
*** default : 같은 패키지(폴더)에 있는 객체들만 허용
*** public : 모든 접근을 허용
*** private : 현재 객체 내에서만 허용
*** protected : 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용

** 사용
*** 클래스 : public, default
*** 생성자 : public, protected, default, private
*** 멤버변수 : public, protected, default, private
*** 멤버메소드 : public, protected, default, private
*** 지역변수 : 접근제한자 사용 불허

* final
** 변수에 적용하면 : 해당 변수의 값은 변경이 불가능
** 변수의 참조에 적용하면 : 참조 변수가 힙 내의 대란 객체를 가리키도록 변경 할 수 없음
** 메서드에 적용하면 : 해당 메서드를 오버라이드 할 수 없음
** 클래스에 적용하면 : 해당 클래스의 하위 클래스를 정의 할 수 없음

* finally
** try 블록 또는 catch 블록 뒤에 둘 수 있는 선택적인 블록을 정의할 때 사용
** finally 블록 내에 둔 코드는 항상 실행
** finally 블록은 뒷마무리 코드를 작성하는데 사용

* finalize()
** finalize() 메서드는 GC가 더 이상의 참조가 존재하지 않는 객체를 발견한 순간 호출하는 메서드다.
** 파일을 닫는 등, 자원 반환 작업을 하는데 보통 사용

=== Java Virtual Machine
==== JVM 특징 [http://d2.naver.com/helloworld/1230]
* 스택 기반의 가상 머신: 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.
* 심볼릭 레퍼런스: 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.
* 가비지 컬렉션(garbage collection): 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.
* 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장: C/C++ 등의 전통적인 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.
* 네트워크 바이트 오더(network byte order): 자바 클래스 파일은 네트워크 바이트 오더를 사용한다.
인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크
바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.
* 런타임 테이터 영역 +
image:http://d2.naver.com/content/images/2015/06/helloworld-1230-4.png[런타임 테이터 영역]

=== Java Garbage Collection [http://d2.naver.com/helloworld/1329]
* Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 가비지 컬렉터(Garbage Collector)가 더 이상 필요 없는 객체를 찾아 지우는 작업을 함
* 가비지 컬렉터는 두 가지 가설 하에 만듬
** 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.
** 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.
* HotSpot VM에서는 크게 2개로 물리적 공간을 나눔
** Young 영역(Yong Generation 영역): 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
** Old 영역(Old Generation 영역): 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.
** 영역 및 데이터 흐름도 +
image:http://d2.naver.com/content/images/2015/06/helloworld-1329-1.png[영역 및 데이터 흐름도]

==== 가비지 컬렉션 과정 - Generational Garbage Collection

=== Collection (Map)
* Collection

** List

**** ArrayList (List)
***** 내부 배열에 기반을 둔 리스트 구현
***** 리스트 요소에 대한 접근이 다른 리스트 기반 클래스보다 빠름
***** 요소가 삽입될 때 추가될 공간을 만들기 위해 객체를 이동시켜야 하고 삭제할 때는 삭제된 공간을 없애기 위해 요소들이 이동해야 하기 때문에 이동이 많아져 요소의 삽입과 삭제가 느림
***** 멀티쓰레드에 대한 동기화 안됨

**** Vector (List)
***** 멀티쓰레드에 대한 동기화

**** LinkedList (Queue, List)
***** 연결된 노드들을 기반으로 구현된 리스트
***** 리스트에 있는 요소를 접근하기 위해서는 링크를 통해 접근해야 하기 때문에 접근 속도가 느림
***** 노드에 대한 참조만을 변경하기 떄문에 삽입, 삭제 작업이 빠름

** Set

*** TreeSet (SortedSet, NavigableSet)
**** 트리 자료 구조를 기반으로 구현
**** 트리 자료 구조를 가지기 때문에 요소는 정렬된 저장
**** 요소에 접근하기 위해서는 반드시 링크를 통해야 하기 떄문에 접근 속도가 다른 Set 보다 느림

*** HashSet (Set)
**** 해쉬 테이블 자료 구조를 기반
**** 요소에 대한 정렬을 보장하지 않음
**** HashSet 은 TreeSet 보다 빠른 속도의 제공하며 null 참조가 저장되는 것을 허용

*** LinkedHasSet

*** EnumSet
**** 비트셋을 기반으로 구현
**** 저장되는 요소들은 열거형 Set 이 생성될 때 지정한 열거형에 포함되어 있는 상수
**** null 요소가 허용 안됨, null 요소를 저장하려고 하면 NullPointException

** Queue
*** 요소를 특정 순서로 지정하고 검색할 수 있는 컬렉션
*** AbstractQueue, ArrayBlockingQueue, ArrayDeque, ConcurrentLinkedDeque, ConcurrentLinkedQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue,
*** LinkedList, LinkedTransferQueue, PriorityBlockingQueue, PriorityQueue, SynchronousQueue

** Deque
*** 큐의 머리와 꼬리 부분 모두에서 삽입과 제거를 할 수 있는 더블 앤드 큐
*** ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque, LinkedList

* Map

** HashMap
*** 해쉬 테이블 자료 구조를 기반으로 하는 맵 구현
*** null 키와 값을 가진 항목을 허용하는데 항목이 저장되는 순서는 보장 하지 않음

** HashTable

** LinkedHashMap
*** 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사
*** Map에 있는 엔트리들의 연결 리스트를 유지되므로 입력한 순서대로 반복 가능

** TreeMap (SortedMap)
*** 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장
*** 검색과 정렬에 적합한 컬렉션

** Properties (HashTable)
*** (String, String) 형태로 저장하는 보다 단순화된 컬렉션

=== 멀티쓰레드
* Thread 란 : 시작점과 종료점을 가지는 일련된 하나의 작업 흐름
* Thread 동기화의 종류
** synchronized : 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용하도록 보장
** volatile : 상호 배제성을 실현하지 않음, 어떤 스레드건 가장 최근에 기록된 값을 읽도록 보장
* 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없음

==== 리플렉션
* 객체 리플렉션이란
** Java 클래스와 객체에 대한 정보를 프로그램 내에서 동적으로 알아낼수 있도록 하는 기능
* 리플렉션 작업
** 클래스 내부에서, 실행 시간에, 메서드와 필드에 대한 정보를 얻을 수 있음
** 어떤 클래스로부터 객체를 생성할 수 있음
** 객체 필드의 유요 범위가 어떻게 선언되어 있는냐에 관계없이, 그 필드에 대한 참조를 얻어내어 값을 가져오거나 설정
* 리플렉션 유용성
** 프로그램이 어떻게 동작하고 있는지에 대한 정보를 실행 시간에 관측하고 조정할 수 있도록 해줌
** 메서드나 생성자, 필드를 직접 접근할 수 있기 때문에 프로그램을 디버깅하거나 테스트 할 때 유용
** 호출할 메서드를 미리 알고 있지 않더라도 그 이름을 사용하여 호출할 수 있다

=== 버전별 변화
* 1.5
** Generic 도입,
** 향상된 for (foreach)
** Enum
** Static Import
** Metadata
** Autoboxing / Unboxing
** ThreadPool
** Annotation
* 1.6
** Garbage First
* 1.7
** 다이아몬드(<>) 지시자 형식 유추
** String in Switch Statements :  Java 6 까지의 버전에서는 Switch-case 문에서 case 조건으로 판단할수 잇는 데이터 형은 원시형 데이터
** Multi-Exception catch
** null 체크 방법 개선
** Bracket Notation for Collection
** 자동 자원 관리 (AutoCloseble)
** 숫자와 관련된 문자에 밑줄 표시
** Path를 이용한 처리 (NIO)
** Fork와 Join
* 1.8
** Lambda Expression
** Nashorn
** Annotation 보안
** OS Process Control
** Default Method Interface (default method, static method)
** Date API, Stream API, , Collection 에 Functional Programming
** 동시성 API 개선
** Permanent Generation 제거 (Metaspace)
* 1.9
** Modular System (Jigsaw)
** Java Shell
** Stream 메소드 추가
** System.in Static

== Spring

=== IoC(Inversion of Control) Container
* IoC 란 : 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말한다.
* Bean : 스프링이 IoC 방식으로 관리하는 오브젝트
* Bean Factory : 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
* Application Context : Bean Factory 확장, 스프링이 제공하는 각종 부가 서비스를 추가 제공

=== DI
* DI 란 : 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동적으로 연결해주는 것
* 종류
** 생성자를 이용한 의존성 주입
** Setter 메서드를 이용한 의존성 주입
** 초기화 인터페이스를 이용한 의존성 주입

=== Bean Scope
* Singleton 범위
* Prototype 범위

=== Spring MVC
* DispatcherServlet : 클라이언트의 요청을 전달받는다. 컨트롤러에게 클라이언트의 요청을 전달하고, 컨트롤러가 리턴한 결과값을 View 에 전달하여 알맞은 응답을 생성하도록 한다.
* HandlerMapping : 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지를 결정한다.
* HandlerAdapter : DispatcherServlet 의 처리 요청을 변환해서 컨트롤러에게 전달하고, 컨트롤러의 응답 결과를 DispatcherServlet 이 요구하는 형식으로 변환한다. 웹브라우저 캐시 등의 설정도 담당
* Controller : 클라이언트의 요청을 처리한 뒤 결과를 리턴한다. 응답 결과에서 보여줄 데이터를 모델에 담아 전달한다.
* ModelAndView : 컨트롤러의 처리 결과를 정보 및 뷰 선택에 필요한 정보를 담는다.
* ViewResolver : 컨트롤러의 처리 결과를 보여줄 뷰를 결정한다.
* View : 컨트롤러의 처리 결과를 화면을 생성한다. JSP나 Velocity 템플릿 파일 등을 이용해서 클라이언트에 응답 결과를 전송한다.

== Software Pattern

=== OOP
* 객체지향 프로그래밍 이란 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것

* 객체
** 우리가 표현할 수 있는 실세계의 모든 사물들
** 데이터를 가지고 있음
** 행위의 집합을 가지고 있음
** 개체를 구분하는 아이덴티를 가지고 있음
** 객체마다 자신만의 책임이 있음

* 클래스
** 객체를 생성하는 청사진
** 객체의 상태를 저장하는데 사용될 속성을 정의
** 객체가 이해할 수 있는 메세지와 메세지에 응답하는 과정을 정의
** 각각의 메세지에 대해 메소드 method 라고 불리우는 프로시저를 만들고, 구현

* 메세지
** 오퍼레이션의 실행을 요청하는 것

* 추상화
** 사람이 객체를 인식할 때 객체의 중요 특징을 추출해 내는데, 이 과정을 "추상화"
** 클래스를 만들 때는 구현하고자 하는 객체의 명사적인 특징만 뽑아내는 것이 아니라 객체가 가지는 동사적인 특징까지도 모두 뽑아내는 추상화 작업이 필요
** 명사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 변수가 탄생하고, 동사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 함수가 탄생
** 추상화 과정에서 주의해야 할 것이 있는데, 추상화 작업 시 앞으로의 확장성을 많이 고려해서 작업

* 캡슐화
** Don't Tell Ask 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라
*** 데미테르의 법칙
**** 메서드에서 생성한 객체의 메서드만 호출
**** 파라미터로 받은 객체의 메서드만 호출
**** 필드로 참조하는 객체의 메서드만 호출
** 멤버변수와 멤버함수를 모두 묶어서 하나의 단위 (클래스, 객체)로 만드는 일련의 작업
** 클래스의 내부가 바뀌어도 클래스를 참조하는 다른 클래스나 함수는 변경할 필요가 없음
** 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근
** 객체는 속성과 메소드로 만들짐 , 일부 속성과 메소드는 객체의 외부에서 접근 (interface) ,다른 속성,메소드는 객체 자신만의 사적인 용도로 예약되어 있고 이것을 구현 implement

* 다형성
** "같은 이름을 가겼으나, 다른 행동을 하는 것"
** 캡슐화, 상속과 함께 작동해서 객체-지향 프로그램의 흐름 제어 flow of control 를 단순화
** 예) "열다"의 경우 "문을 열다", "지갑을 열다", "지퍼를 열다", "파일을 열다" 이름은 같지만 상황에 따란 하는 여는 행동이 완전히 다른다는 것
** 객체 내에서 다형성이 발생 (미닫이 여닫이, Overload)
** 하나의 클래스 내부에 같은 이름을 가진 멤버 함수들이 존재하는 경우와 조상 클래스와 자손 클래스가 같은 이름을 가진 멤버 함수들을 가지는 경우 (Overloading, Overriding)
*** Overloading
**** 클래스의 메서드끼리 이름은 같은데 매개변수가 다르며 메서드 오버로딩이 일어남
**** 메서드를 호출할 때 어떤 메서드를 사용하지는 컴파일 할 때 결정
*** Overriding
**** 자식 클래스에 있는 인스턴스 메서드가 부모 클래스의 접근 가능한 메서드와 동일한 이름과 매개변수를 가지면 오버라이딩 함
**** 오버라이딩 되면 동적 디스패치가 가능해짐
**** 오버라이딩은 객체 지향 프로그램밍의 가장 핵심이 되는 기능

* 상속
** 조상 객체 생성기(클래스)의 모든 것이 후손 객체 생성기(클래스)에게 전달되는 것
** 코드의 재사용 보다 계층구조를 표현 하는 것 (IS-A 명확 할 때)

* 재사용
** 상속보단 조립
** 상속을 사용하면 상위 클래스에 구현된 기능을 그대로 재사용할 수 있기 때문에, 상속을 사용하면 재사용을 쉽게 할 수 있는 것은 분명 (문제가 많음)
*** 상위클래스 변경이 어려움, 클래스의 불필요한 증가, 상속의 오사용
*** 인터페이스르 재사용
**** 인터페이스를 사용하는 코드는 재사용 가능 (재사용)
***** 인터페이스 구현체 A가 있음 새로운 구현체 B 가 생기드라도 인터페이스를 사용하던 코드 로직(비즈니스)는 그대로 사용
**** 인터페이스 사용 시 변경이 안될는 일 없음, 테스트 하기 쉽다, 부가적인 기능 추가 수월

=== 추상클래스와 인터페이스의 차이
* 추상 클래스와 인터페이스는 상속받는 클래스 혹은 인터페이스 안에 있는 추상 메소드를 구현하도록 강제
** 추상클래스
** 인터페이스

=== AOP
* 횡단 관심사의 모듈화, 분리 (애플리케이션의 여러 부분에 영향을 주는 기능)
** 횡단 관심사 : 한 애플리케이션의 야러 부분에 걸쳐 있는 기능을 가리켜 횡단 관심사
** 예) 보안은 하나의 애플리케이션내에서도 여러 객체 메소드의 보안 규칙에 영향을 미치는 횡단 관심사
* 어드바이스 : 애스펙트가 해야 할 작업, 무엇을 언제 할지 결정
* before, after, after-returing, after-throwing, around
* 조인 포인트 : 어드바이스를 적용할 수 있는 곳, 즉 조인 포인트는 애플리케이션 실행에 애스펙트를 끼워 넣을 수 있는 지점
* 포인트커트 : 애스펙트가 어드바이스할 조인 포인트, 한 애스펙트가 전체 애플리케이션의 모든 조인 포인트를 다 어드바이스 할 수는 없는 노릇
* 애스펙트 : 어드바이스 + 포인트커트 ((언제, 무엇), (어디서))
* 인트로덕션 : 기존 클래스에 코드를 변경 없이도 새 메소드나 멤버 변수를 추가 하는 기능
* 위빙 : 타킷 객체에 애스펙트를 적용해서 새로운 프록시 객체를 생성하는 절차
** compile time, classload time, runtime

=== SOLID
* Single Responsibility Principle : 단일책임의 원칙
** Single Responsibility Principle 란 클래스는 하나의 책임을 가져야하며 그 책임에 대한 이유로 변경되어야 한다.
** 책임 : '변경을 위한 이유', 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것
** 예시
[source,java, indent=0]
class Student {
  // 회사에서 일을 합니다.
  public void work() {
    ......
  }
  // 학교에서 공부를 합니다.
  public void study() {
    ......
  }
}

* Open Close Principle : 개방폐쇄의 원칙
** 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

* The Liskov Substitution Principle : 리스코브 치환의 원칙
** 서브 타입은 그것의 기반 타입으로 치환 가능해야 한다.

* Interface Segregation Principle : 인터페이스 분리의 원칙
** 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안 된다.

* Dependency Inversion Principle : 의존성역전의 원칙
** 상위 수준의 모듈은 하위 수준의 모둘에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
** 추상화는 구체적으로 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

=== 디자인패턴

== 알고리즘 & 자료구조

=== 알고리즘이란?
* 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해놓은 명세서
* 용어
** 동적계획법 : 동적 계획법의 원리는 매우 간단하다. 일반적으로 주어진 문제를 풀기 위해서,
문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음,
그것을 결합하여 최종적인 목적에 도달하는 것이다. 각 하위 문제의 해결을 계산한 뒤,
그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다.
이러한 방법으로 동적 계획법은 계산 횟수를 줄일 수 있다.
특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다.

=== 자료구조란?
 * 자료를 효율적으로 표현하고 저장, 처리하기 위해 정리하는 것
 * 컴퓨터에서 사용할 자료를 더 효율적으로 저장하고 처리하기 위해서 자료의 특성과 사용 용도에 따라 분류하고 정리하는 것, 즉 구조화하는 것

=== 선형 리스트

=== 큐

=== 스택

=== 해시 테이블

=== ETC
* AVL-TREE
* Red-Black Tree

== 운영체제
=== 프로세스
=== 스레드
=== 메모리

== 네트워크
=== TCP
* TCP 3-WAY HAND SHAKING
** TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미
** 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 함
** 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 함
** 과정
*** A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.
*** B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
*** A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.

=== Http
* Method
** GET
*** idempotent
*** 서버에게 리소스를 달라고 요청하기 위해 쓰임
*** HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구
** HEAD
*** 정확히 GET 처러 행동하지만, 서버는 응답으로 헤더만을 돌려줌 (엔터티 본문 X)
*** 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
*** 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
*** 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
** PUT
*** 서버에서 문서를 씀
*** 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해줌
*** 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
*** 콘텐츠를 변경할 수 있게 해주기 떄문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구
** POST
*** non-idempotent
*** 서버에 입력 데이터를 전송하기 위해서 설계
** TRACE
*** 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
** OPTION
*** 웹 서버에게 여려 가지 종류의 지원 범위에 대해서 물어봄
** DELETE
*** 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
* Restful API
** Representational State Transfer 라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개
** REST는 요소로는 크게 리소스,메서드,메세지 3가지 요소로 구성

== Q&A

=== Q1 : 쓰레드와 프로세스의 차이는?
* A1 : 프로세스와 쓰레드는 서로 관계가 있으나 기본적으로는 다르다.
프로세스는 실행되고 있는 프로그램 개체이다.
프로세스는 CPU 시간이나 메모리 등이 시스템 자원이 할당되는 독립적인 객체이다.
각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 할 수 없다.
어떤 프로세스는 다른 프로세스의 자원을 접근하려면 프로세스 간 통신(IPC)을 사용하여야 한다.
프로세스간 통신 방법으로는 파이프나 파일, 소켓 등이 있다.
쓰레드는 프로세스와 같은 스택 공간을 사용하며, 여러 쓰레드는 그 상태의 일부를 서로 공유한다.
통상 같은 메모리를 읽고 쓰는 여러 프로세스를 생성 할 수 있다.
프로세스가 다른 프로세스의 메모리를 읽고 쓰는 여러 프로세스를 생성 할 수 있다.
프로세스가 다른 프로세스의 메모리를 직접적으로 접근할 수 없는 것과는 다르다.
그러나 각각의 쓰레드에는 별도의 레지스터와 스택이 배정된다.
다른 쓰레드가 해당 스택 메모리를 읽고 쓰는 것은 허용된다.
쓰레드는 프로세스의 특정한 수행 경로다.
한 쓰레드가 프로세스 자원을 변경하면, 다른 이웃 쓰레드도 그 변경 결과를 즉시 볼 수 있다.

Q2 : DB
A1 :

Q3 : MSA 에서 Distributed Transaction
A3 :

Q4 : 1000 * 1000 셀에 한가지 셀에 1000가지 색이 들어 갈때 필요한 메모리의 양
A4 : 한셀에 1000가지 색이 들어간다면 한셀에 필요한 비트수는 2^10 = 1024 로 유도하며 품

Q5 : 문자열로 된 숫자 Int 변환
A5 :
[source,java, indent=0]
public static int StringToInt(String str) {
		int i = 0, num = 0, sign = 1;
		char[] c = str.toCharArray();

		if (c[i] == '-') {
			i++;
			sign = -1;
		}

		while (i < c.length) {
			num *= 10;
			num += c[i] - '0';
			i++;
		}

		return num * sign;
	}

Q6 : 0 ~ 1000의 숫자중 중복 가능하게 1000개의 숫자를 뽑았을때, 이들 중 중간값
A6 : 카운팅 소트, 1000개의 변수를 갖는 배열, 숫자 값을 인덱스 , 해당 숫자가 나올떄마다 해당 변수의 값을 증가, 갯수를 앞에서부터 더해 500 이상, 지점의 인덱스

Q8 : Multi Thread가 고려된 Singleton 구현

Q9 : 사용해본 DBMS 들의 장담점을 설명해보라
A9 :

Q10 : 클래스와 객체의 차이
A10 :


=== 빅오표기볍 (시간, 공간)