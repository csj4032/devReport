= Interview
:source-language: java
:source-highlighter: pygments

== Java

* Overloading
** 클래스의 메서드끼리 이름은 같은데 매개변수가 다르며 메서드 오버로딩이 일어남
** 메서드를 호출할 때 어떤 메서드를 사용하지는 컴파일 할 때 결정

* Overriding
** 자식 클래스에 있는 인스턴스 메서드가 부모 클래스의 접근 가능한 메서드와 동일한 이름과 매개변수를 가지면 오버라이딩 함
** 오버라이딩 되면 동적 디스패치가 가능해짐
** 오버라이딩은 객체 지향 프로그램밍의 가장 핵심이 되는 기능

* Hiding
** 부모 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스와 동일한 이름으로 자식 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스의 이름을 만들면, 자식에서 만든 요소가 부모에 있는 요소를 하이딩함

* Shadowing
** 변수, 메서드, 클래스, 인터페이스의 이름을 같은 영역에서 동일하게 사용하면 이름이 겹쳐 새도윙이 발생
** 어떤 대상이 섀도윙되면, 해당 대상을 이름으로 접근할 수 없음

* 추상클래스와 인터페이스의 차이
** 추상 클래스와 인터페이스는 상속받는 클래스 혹은 인터페이스 안에 있는 추상 메소드를 구현하도록 강제한다.

== Spring

=== IoC container

=== DispatcherServlet

== Software Pattern

=== OOP

=== AOP

=== SOLID
* Single Responsibility Principle : 단일책임의 원칙
** Single Responsibility Principle 란 클래스는 하나의 책임을 가져야하며 그 책임에 대한 이유로 변경되어야 한다.
** 책임 : '변경을 위한 이유', 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것
** 예시
[source,java, indent=0]
class Student {
  // 회사에서 일을 합니다.
  public void work() {
    ......
  }
  // 학교에서 공부를 합니다.
  public void study() {
    ......
  }
}

* Open Close Principle : 개방폐쇄의 원칙

* The Liskov Substitution Principle : 리스코브 치환의 원칙
** '서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.'

* Interface Segregation Principle : 인터페이스 분리의 원칙
**

* Dependency Inversion Principle : 의존성역전의 원칙

== 알고리즘 & 자료구조

=== 알고리즘이란?
 * 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해놓은 명세서

=== 자료구조란?
 * 자료를 효율적으로 표현하고 저장, 처리하기 위해 정리하는 것
 * 컴퓨터에서 사용할 자료를 더 효율적으로 저장하고 처리하기 위해서 자료의 특성과 사용 용도에 따라 분류하고 정리하는 것, 즉 구조화하는 것

== 선형 리스트

== 큐

== 스택

== 해시 테이블

== ETC

Q1 :
A1 :



=== 빅오표기볍