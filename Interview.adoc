= Interview
:source-language: java
:source-highlighter: pygments

== Java

=== 용어

    * Hiding
        ** 부모 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스와 동일한 이름으로 자식 클래스의 필드, 정적 메서드, 클래스, 또는 인터페이스의 이름을 만들면, 자식에서 만든 요소가 부모에 있는 요소를 하이딩함

    * Shadowing
        ** 변수, 메서드, 클래스, 인터페이스의 이름을 같은 영역에서 동일하게 사용하면 이름이 겹쳐 새도윙이 발생
        ** 어떤 대상이 섀도윙되면, 해당 대상을 이름으로 접근할 수 없음

    * Deep copy, Shallow Copy
        ** 배열이나 객체를 복사할 때 단순히 참조만 복사하는 것을 shallow copy, 원본과 같은 데이터를 저장하고 있는 새로운 객체나 배열을 생성하는 것은 deep copy 라고 한다.

    * 접근제한자

        ** 종류
            *** default : 같은 패키지(폴더)에 있는 객체들만 허용
            *** public : 모든 접근을 허용
            *** private : 현재 객체 내에서만 허용
            *** protected : 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용

        ** 사용
            *** 클래스 : public, default
            *** 생성자 : public, protected, default, private
            *** 멤버변수 : public, protected, default, private
            *** 멤버메소드 : public, protected, default, private
            *** 지역변수 : 접근제한자 사용 불허

=== Java Virtual Machine
==== JVM 특징 [http://d2.naver.com/helloworld/1230]
* 스택 기반의 가상 머신: 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.
* 심볼릭 레퍼런스: 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.
* 가비지 컬렉션(garbage collection): 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.
* 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장: C/C++ 등의 전통적인 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.
* 네트워크 바이트 오더(network byte order): 자바 클래스 파일은 네트워크 바이트 오더를 사용한다.
인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크
바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.
* 런타임 테이터 영억 +
image:http://d2.naver.com/content/images/2015/06/helloworld-1230-4.png[런타임 테이터 영억]

=== Java Garbage Collection [http://d2.naver.com/helloworld/1329]
* 지극히 개인적이고 주관적인 판단 기준을 먼저 밝힌다면, 가비지 컬렉션(Garbage Collection, 이하 GC)에 대해 잘 알고 있을수록 실력이 좋은 Java 개발자라고 생각합니다.
GC 과정에 관심을 가질 정도라면 규모가 일정 이상인 애플리케이션을 제작해 본 경험이 있을 것입니다.
또, 어떤 GC 알고리즘을 선택할 것인지 고민할 정도면 스스로 제작한 애플리케이션의 특징을 정확히 이해하고 있다고 볼 수 있습니다.
이러한 판단 기준이 보편적이지는 않지만, GC에 대한 이해는 훌륭한 Java 개발자가 되기 위한 필수 조건이라는 데에는 별다른 이견이 없을 것입니다.
이 글에서는 GC 이론을 되도록 쉽게 소개하겠습니다. 피가 되고 살이 되는 글이 되기를 바랍니다.

==== 가비지 컬렉션 과정 - Generational Garbage Collection

=== Collection


=== 멀티쓰레드
    * 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없음
    * Thread 동기화의 종류
        ** synchronized : 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용하도록 보장
        ** volatile : 상호 배제성을 실현하지 않음, 어떤 스레드건 가장 최근에 기록된 값을 읽도록 보장

=== 버전별 변화
    * 1.5
        ** Generic 도입
        ** 향상된 for (foreach)
        ** Enum
        ** Static Import
        ** Metadata
        ** Autoboxing / Unboxing
        ** ThreadPool
        ** Annotation
    * 1.6
        ** Garbage First
     * 1.7
        ** 다이아몬드(<>) 지시자 형식 유추
        ** String in Switch Statements :  Java 6 까지의 버전에서는 Switch-case 문에서 case 조건으로 판단할수 잇는 데이터 형은 원시형 데이터
        ** Multi-Exception catch
        ** null 체크 방법 개선
        ** Bracket Notation for Collection
        ** 자동 자원 관리 (AutoCloseble)
        ** 숫자와 관련된 문자에 밑줄 표시
        ** Path를 이용한 처리 (NIO)
        ** Fork와 Join
     * 1.8
        ** Lambda Expression
        ** Nashorn
        ** Annotation 보안
        ** OS Process Control
        ** Default Method Interface (default method, static method)
        ** Date API, Stream API, , Collection 에 Functional Programming
        ** 동시성 API 개선
        ** Permanent Generation 제거 (Metaspace)
     * 1.9
        ** Modular System (Jigsaw)
        ** Java Shell
        ** Stream 메소드 추가
        ** System.in Static

== Spring

=== IoC(Inversion of Control) Container
    * IoC 란 : 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말한다.
    * Bean : 스프링이 IoC 방식으로 관리하는 오브젝트
    * Bean Factory : 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
    * Application Context : Bean Factory 확장, 스프링이 제공하는 각종 부가 서비스를 추가 제공
=== DI
    * DI 란 : 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동적으로 연결해주는 것
    * 종류
        ** 생성자를 이용한 의존성 주입
        ** Setter 메서드를 이용한 의존성 주입
        ** 초기화 인터페이스를 이용한 의존성 주입

=== Bean Scope
    * Singleton 범위
    * Prototype 범위

=== Spring MVC
    * DispatcherServlet : 클라이언트의 요청을 전달받는다. 컨트롤러에게 클라이언트의 요청을 전달하고, 컨트롤러가 리턴한 결과값을 View 에 전달하여 알맞은 응답을 생성하도록 한다.
    * HandlerMapping : 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지를 결정한다.
    * HandlerAdapter : DispatcherServlet 의 처리 요청을 변환해서 컨트롤러에게 전달하고, 컨트롤러의 응답 결과를 DispatcherServlet 이 요구하는 형식으로 변환한다. 웹브라우저 캐시 등의 설정도 담당
    * Controller : 클라이언트의 요청을 처리한 뒤 결과를 리턴한다. 응답 결과에서 보여줄 데이터를 모델에 담아 전달한다.
    * ModelAndView : 컨트롤러의 처리 결과를 정보 및 뷰 선택에 필요한 정보를 담는다.
    * ViewResolver : 컨트롤러의 처리 결과를 보여줄 뷰를 결정한다.
    * View : 컨트롤러의 처리 결과를 화면을 생성한다. JSP나 Velocity 템플릿 파일 등을 이용해서 클라이언트에 응답 결과를 전송한다.

== Software Pattern

=== OOP

* 캡슐화
** 멤버변수와 멤버함수를 모두 묶어서 하나의 단위 (클래스, 객체)로 만드는 일련의 작업
** 클래스의 내부가 바뀌어도 클래스를 참조하는 다른 클래스나 함수는 변경할 필요가 없음

* 추상화
** 사람이 객체를 인식할 때 객체의 중요 특징을 추출해 내는데, 이 과정을 "추상화"
** 클래스를 만들 때는 구현하고자 하는 객체의 명사적인 특징만 뽑아내는 것이 아니라 객체가 가지는 동사적인 특징까지도 모두 뽑아내는 추상화 작업이 필요
** 명사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 변수가 탄생하고, 동사적인 특징을 뽑아내는 추상화 과정을 거쳐 멤버 함수가 탄생
** 추상화 과정에서 주의해야 할 것이 있는데, 추상화 작업 시 앞으로의 확장성을 많이 고려해서 작업

* 다형성
** "같은 이름을 가겼으나, 다른 행동을 하는 것"
** 예) "열다"의 경우 "문을 열다", "지갑을 열다", "지퍼를 열다", "파일을 열다" 이름은 같지만 상황에 따란 하는 여는 행동이 완전히 다른다는 것
** 객체 내에서 다형성이 발생 (미닫이 여닫이, Overload)
** 하나의 클래스 내부에 같은 이름을 가진 멤버 함수들이 존재하는 경우와 조상 클래스와 자손 클래스가 같은 이름을 가진 멤버 함수들을 가지는 경우 (Overloading, Overriding)
*** Overloading
**** 클래스의 메서드끼리 이름은 같은데 매개변수가 다르며 메서드 오버로딩이 일어남
**** 메서드를 호출할 때 어떤 메서드를 사용하지는 컴파일 할 때 결정
*** Overriding
**** 자식 클래스에 있는 인스턴스 메서드가 부모 클래스의 접근 가능한 메서드와 동일한 이름과 매개변수를 가지면 오버라이딩 함
**** 오버라이딩 되면 동적 디스패치가 가능해짐
**** 오버라이딩은 객체 지향 프로그램밍의 가장 핵심이 되는 기능

=== 추상클래스와 인터페이스의 차이
* 추상 클래스와 인터페이스는 상속받는 클래스 혹은 인터페이스 안에 있는 추상 메소드를 구현하도록 강제한다.

=== AOP
    * 횡단 관심사의 모듈화, 분리 (애플리케이션의 여러 부분에 영향을 주는 기능)
        ** 횡단 관심사 : 한 애플리케이션의 야러 부분에 걸쳐 있는 기능을 가리켜 횡단 관심사
        ** 예) 보안은 하나의 애플리케이션내에서도 여러 객체 메소드의 보안 규칙에 영향을 미치는 횡단 관심사
    * 어드바이스 : 애스펙트가 해야 할 작업, 무엇을 언제 할지 결정
        * before, after, after-returing, after-throwing, around
    * 조인 포인트 : 어드바이스를 적용할 수 있는 곳, 즉 조인 포인트는 애플리케이션 실행에 애스펙트를 끼워 넣을 수 있는 지점
    * 포인트커트 : 애스펙트가 어드바이스할 조인 포인트, 한 애스펙트가 전체 애플리케이션의 모든 조인 포인트를 다 어드바이스 할 수는 없는 노릇
    * 애스펙트 : 어드바이스 + 포인트커트 ((언제, 무엇), (어디서))
    * 인트로덕션 : 기존 클래스에 코드를 변경 없이도 새 메소드나 멤버 변수를 추가 하는 기능
    * 위빙 : 타킷 객체에 애스펙트를 적용해서 새로운 프록시 객체를 생성하는 절차
        ** compile time, classload time, runtime

=== SOLID
* Single Responsibility Principle : 단일책임의 원칙
** Single Responsibility Principle 란 클래스는 하나의 책임을 가져야하며 그 책임에 대한 이유로 변경되어야 한다.
** 책임 : '변경을 위한 이유', 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것
** 예시
[source,java, indent=0]
class Student {
  // 회사에서 일을 합니다.
  public void work() {
    ......
  }
  // 학교에서 공부를 합니다.
  public void study() {
    ......
  }
}

* Open Close Principle : 개방폐쇄의 원칙
** 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

* The Liskov Substitution Principle : 리스코브 치환의 원칙
** 서브 타입은 그것의 기반 타입으로 치환 가능해야 한다.

* Interface Segregation Principle : 인터페이스 분리의 원칙
** 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안 된다.

* Dependency Inversion Principle : 의존성역전의 원칙
** 상위 수준의 모듈은 하위 수준의 모둘에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
** 추상화는 구체적으로 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

=== 디자인패턴

== 알고리즘 & 자료구조

=== 알고리즘이란?
 * 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해놓은 명세서
 * 용어
    ** 동적계획법 : 동적 계획법의 원리는 매우 간단하다. 일반적으로 주어진 문제를 풀기 위해서,
    문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음,
    그것을 결합하여 최종적인 목적에 도달하는 것이다. 각 하위 문제의 해결을 계산한 뒤,
    그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다.
    이러한 방법으로 동적 계획법은 계산 횟수를 줄일 수 있다.
    특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다.

=== 자료구조란?
 * 자료를 효율적으로 표현하고 저장, 처리하기 위해 정리하는 것
 * 컴퓨터에서 사용할 자료를 더 효율적으로 저장하고 처리하기 위해서 자료의 특성과 사용 용도에 따라 분류하고 정리하는 것, 즉 구조화하는 것

=== 선형 리스트

=== 큐

=== 스택

=== 해시 테이블

=== ETC
 * AVL-TREE
 * Red-Black Tree

== 운영체제
=== 프로세스
=== 스레드
=== 메모리

== 네트워크
=== TCP
    * TCP 3-WAY HAND SHAKING
        ** TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미
        ** 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 함
        ** 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 함
        ** 과정
            *** A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.
            *** B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
            *** A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.

=== Http
    * Method
        ** GET
            *** idempotent
            *** 서버에게 리소스를 달라고 요청하기 위해 쓰임
            *** HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구
        ** HEAD
           *** 정확히 GET 처러 행동하지만, 서버는 응답으로 헤더만을 돌려줌 (엔터티 본문 X)
           *** 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
           *** 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
           *** 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
        ** PUT
            *** 서버에서 문서를 씀
            *** 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해줌
            *** 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
            *** 콘텐츠를 변경할 수 있게 해주기 떄문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구
        ** POST
            *** non-idempotent
            *** 서버에 입력 데이터를 전송하기 위해서 설계
        ** TRACE
            *** 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
        ** OPTION
            *** 웹 서버에게 여려 가지 종류의 지원 범위에 대해서 물어봄
        ** DELETE
            *** 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
    * Restful API
        ** Representational State Transfer 라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개
        ** REST는 요소로는 크게 리소스,메서드,메세지 3가지 요소로 구성
== Q&A

Q1 : 장애대응
A1 :

Q2 : DB
A1 :

Q3 : MSA 에서 Distributed Transaction
A3 :

Q4 : 1000 * 1000 셀에 한가지 셀에 1000가지 색이 들어 갈때 필요한 메모리의 양
A4 : 한셀에 1000가지 색이 들어간다면 한셀에 필요한 비트수는 2^10 = 1024 로 유도하며 품

Q5 : 문자열로 된 숫자 Int 변환
A5 :
[source,java, indent=0]
public static int StringToInt(String str) {
		int i = 0, num = 0, sign = 1;
		char[] c = str.toCharArray();

		if (c[i] == '-') {
			i++;
			sign = -1;
		}

		while (i < c.length) {
			num *= 10;
			num += c[i] - '0';
			i++;
		}

		return num * sign;
	}

Q6 : 0 ~ 1000의 숫자중 중복 가능하게 1000개의 숫자를 뽑았을때, 이들 중 중간값
A6 : 카운팅 소트, 1000개의 변수를 갖는 배열, 숫자 값을 인덱스 , 해당 숫자가 나올떄마다 해당 변수의 값을 증가, 갯수를 앞에서부터 더해 500 이상, 지점의 인덱스

Q8 : Singleton Multi Thread 고려해서 구현

Q9 : 써본 DB가 뭐고 장단점 들을 말해보라

Q10 : 클래스와 객체의 차이!

=== 빅오표기볍 (시간, 공간)